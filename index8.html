<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Yasin Ullah, Pakistani">
    <title>Isnad Narrators Explorer</title>
    <style>
        /* Basic Reset & Root Variables */
        :root {
            --bg-color-light: #ffffff;
            --text-color-light: #333333;
            --primary-color-light: #007bff;
            --secondary-color-light: #6c757d;
            --border-color-light: #dee2e6;
            --accent-color-light: #e9ecef;
            --link-color-light: #0056b3;
            --highlight-color-light: #f8f9fa;
            --error-color-light: #dc3545;
            --success-color-light: #28a745;
            --graph-node-color-light: #007bff;
            --graph-edge-color-light: #6c757d;
            --graph-text-color-light: #ffffff;
            --graph-highlight-color-light: #ffc107;

            --bg-color-dark: #212529;
            --text-color-dark: #dee2e6;
            --primary-color-dark: #0d6efd; /* Slightly brighter blue for dark */
            --secondary-color-dark: #adb5bd;
            --border-color-dark: #495057;
            --accent-color-dark: #343a40;
            --link-color-dark: #6ea8fe;
            --highlight-color-dark: #495057;
            --error-color-dark: #f8d7da;
            --success-color-dark: #d1e7dd;
            --graph-node-color-dark: #0d6efd;
            --graph-edge-color-dark: #adb5bd;
            --graph-text-color-dark: #e9ecef;
            --graph-highlight-color-dark: #ffca2c;

            --bg-color: var(--bg-color-light);
            --text-color: var(--text-color-light);
            --primary-color: var(--primary-color-light);
            --secondary-color: var(--secondary-color-light);
            --border-color: var(--border-color-light);
            --accent-color: var(--accent-color-light);
            --link-color: var(--link-color-light);
            --highlight-color: var(--highlight-color-light);
            --error-color: var(--error-color-light);
            --success-color: var(--success-color-light);
            --graph-node-color: var(--graph-node-color-light);
            --graph-edge-color: var(--graph-edge-color-light);
            --graph-text-color: var(--graph-text-color-light);
            --graph-highlight-color: var(--graph-highlight-color-light);

            --font-family-sans-serif: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --font-family-urdu: 'Noto Nastaliq Urdu', 'Nafees Web Naskh', 'Pak Nastaleeq', 'Urdu Typesetting', serif; /* Add fallback Urdu fonts */
            --font-family-base: var(--font-family-sans-serif);
        }

        .dark-theme {
            --bg-color: var(--bg-color-dark);
            --text-color: var(--text-color-dark);
            --primary-color: var(--primary-color-dark);
            --secondary-color: var(--secondary-color-dark);
            --border-color: var(--border-color-dark);
            --accent-color: var(--accent-color-dark);
            --link-color: var(--link-color-dark);
            --highlight-color: var(--highlight-color-dark);
            --error-color: var(--error-color-dark);
            --success-color: var(--success-color-dark);
            --graph-node-color: var(--graph-node-color-dark);
            --graph-edge-color: var(--graph-edge-color-dark);
            --graph-text-color: var(--graph-text-color-dark);
            --graph-highlight-color: var(--graph-highlight-color-dark);
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family-base);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        /* RTL Specific Styles */
        html[dir="rtl"] body {
            font-family: var(--font-family-urdu), var(--font-family-sans-serif); /* Prioritize Urdu font */
        }
        html[dir="rtl"] .header-title {
            margin-inline-start: auto;
            margin-inline-end: 1rem;
        }
        html[dir="rtl"] .controls > *,
        html[dir="rtl"] .header-controls > * {
            margin-inline-start: 0.5rem;
            margin-inline-end: 0;
        }
        html[dir="rtl"] .narrator-item,
        html[dir="rtl"] .detail-item {
             text-align: right;
        }
        html[dir="rtl"] .detail-label {
            margin-inline-end: 0.5rem;
            margin-inline-start: 0;
        }
        html[dir="rtl"] .pagination button:first-child {
            border-top-right-radius: 0.25rem;
            border-bottom-right-radius: 0.25rem;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
        html[dir="rtl"] .pagination button:last-child {
            border-top-left-radius: 0.25rem;
            border-bottom-left-radius: 0.25rem;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        /* Layout */
        .container {
            width: 95%;
            max-width: 1400px;
            margin: 1rem auto;
            padding: 1rem;
            background-color: var(--accent-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: var(--primary-color);
            color: var(--bg-color-light); /* Header text usually white/light */
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-inline-end: auto; /* Pushes controls to the other side */
        }

        .header-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1rem;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 1rem;
            overflow: hidden; /* Prevent container growth issues */
        }

        @media (min-width: 992px) {
            .main-content {
                flex-direction: row;
            }
            .narrator-list-container {
                width: 35%;
                max-height: 70vh; /* Limit height */
                overflow-y: auto;
            }
            .details-and-viz-container {
                width: 65%;
                display: flex;
                flex-direction: column;
                gap: 1rem;
                max-height: 70vh; /* Limit height */
                overflow-y: auto; /* Allow scrolling within this panel */
            }
            .narrator-details, .visualization-container {
                 flex-shrink: 0; /* Prevent shrinking */
            }
        }

        .narrator-list-container, .details-and-viz-container {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
        }

        .narrator-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .narrator-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .narrator-item:last-child {
            border-bottom: none;
        }
        .narrator-item:hover, .narrator-item.selected {
            background-color: var(--highlight-color);
        }
        .narrator-item strong {
            color: var(--primary-color);
        }

        .narrator-details {
            padding: 1rem;
        }
        .detail-item {
            margin-bottom: 0.75rem;
            word-wrap: break-word;
        }
        .detail-label {
            font-weight: bold;
            color: var(--secondary-color);
            margin-inline-end: 0.5rem;
        }
        .detail-value a {
            color: var(--link-color);
            text-decoration: none;
            cursor: pointer;
        }
        .detail-value a:hover {
            text-decoration: underline;
        }
        .detail-value .tag {
            display: inline-block;
            background-color: var(--secondary-color);
            color: var(--bg-color-light);
            padding: 0.2em 0.6em;
            border-radius: 0.25rem;
            font-size: 0.85em;
            margin: 0.1em;
        }

        .notes-section textarea {
            width: 100%;
            min-height: 80px;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-top: 0.5rem;
            font-family: inherit;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .visualization-container {
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden; /* Crucial for panning/zooming */
            min-height: 300px; /* Ensure it has some height */
            background-color: var(--bg-color);
            cursor: grab;
        }
        .visualization-container:active {
            cursor: grabbing;
        }

        #graph-svg {
            display: block;
            width: 100%;
            height: 100%;
            min-height: 300px; /* Match container */
        }

        #graph-svg .node circle {
            stroke: var(--border-color);
            stroke-width: 1.5px;
            fill: var(--graph-node-color);
            cursor: pointer;
        }
        #graph-svg .node.selected circle {
            stroke: var(--graph-highlight-color);
            stroke-width: 3px;
        }
        #graph-svg .node text {
            font-size: 10px;
            fill: var(--text-color); /* Use text color for visibility */
            text-anchor: middle;
            pointer-events: none; /* Allow clicks to pass through to circle */
            dominant-baseline: central;
        }
        html[dir="rtl"] #graph-svg .node text {
             font-family: var(--font-family-urdu), var(--font-family-sans-serif);
        }
        #graph-svg .link {
            stroke: var(--graph-edge-color);
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        #graph-svg .link.teacher-link {
             stroke-dasharray: 5, 5; /* Dashed line for teachers */
        }
        #graph-svg .link.student-link {
             /* Solid line for students (default) */
        }


        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }
        .pagination button {
            margin: 0 2px;
            padding: 0.5rem 0.75rem;
        }
        .pagination span {
            margin: 0 0.5rem;
        }

        /* Form Elements */
        input[type="text"], input[type="search"], select, textarea {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        select {
             appearance: none; /* For custom arrow later if needed */
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007bff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
             background-repeat: no-repeat;
             background-position: right .7em top 50%, 0 0;
             background-size: .65em auto, 100%;
             padding-right: 2em; /* Make space for arrow */
        }
        html[dir="rtl"] select {
            background-position: left .7em top 50%, 0 0;
            padding-left: 2em;
            padding-right: 0.5rem;
        }
        .dark-theme select {
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236ea8fe%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
        }


        button {
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
            cursor: pointer;
            border: 1px solid var(--primary-color);
            background-color: var(--primary-color);
            color: var(--bg-color-light);
            border-radius: 4px;
            transition: background-color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }
        button:hover {
            background-color: var(--link-color); /* Darker shade */
            border-color: var(--link-color);
        }
        button.secondary {
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
        }
        button.secondary:hover {
            opacity: 0.85;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000;
            flex-direction: column;
            text-align: center;
        }
        .loading-overlay progress {
            width: 80%;
            max-width: 400px;
            margin-top: 1rem;
        }
        .status-message {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            text-align: center;
        }
        .status-message.error {
            background-color: var(--error-color);
            color: var(--bg-color-dark); /* Better contrast for light red */
        }
        .dark-theme .status-message.error {
             color: var(--text-color-light); /* Better contrast for dark red */
        }
        .status-message.success {
            background-color: var(--success-color);
            color: var(--bg-color-dark); /* Better contrast for light green */
        }
         .dark-theme .status-message.success {
             color: var(--text-color-light); /* Better contrast for dark green */
        }

        /* Print specific styles */
        @media print {
            body {
                font-family: sans-serif; /* Use standard fonts for printing */
                background-color: #fff !important; /* Force white background */
                color: #000 !important; /* Force black text */
            }
            header, .controls, .narrator-list-container, .narrator-details, footer, .header-controls button, .pagination, .status-message, #notes-textarea, #save-note-button, #bookmark-button, #print-viz-button {
                display: none !important;
            }
            .container {
                width: 100%;
                max-width: none;
                margin: 0;
                padding: 0;
                box-shadow: none;
                border: none;
            }
            .main-content, .details-and-viz-container {
                display: block;
                width: 100%;
                height: auto;
                overflow: visible;
                max-height: none;
                border: none;
                padding: 0;
            }
            .visualization-container {
                border: none;
                min-height: auto;
                width: 100%;
                height: auto;
                overflow: visible;
                page-break-inside: avoid; /* Try to keep viz on one page */
            }
            #graph-svg {
                width: 100%;
                height: auto;
                min-height: auto;
            }
            /* Ensure SVG colors are printable */
            #graph-svg .node circle {
                fill: #ccc !important;
                stroke: #333 !important;
            }
             #graph-svg .node.selected circle {
                stroke: #000 !important;
                stroke-width: 2px !important;
            }
            #graph-svg .node text {
                fill: #000 !important;
                font-size: 8pt !important; /* Adjust size for print */
            }
            #graph-svg .link {
                stroke: #666 !important;
            }
            /* Hide specific SVG elements if needed */
            .no-print {
                display: none !important;
            }
        }

    </style>
</head>
<body>

    <header>
        <div class="header-title" data-translate-en="Isnad Narrators Explorer" data-translate-ur="اسناد راوی ایکسپلورر">Isnad Narrators Explorer</div>
        <div class="header-controls">
            <button id="lang-toggle" data-translate-en="اردو" data-translate-ur="English">اردو</button>
            <button id="theme-toggle" data-translate-en="Dark Mode" data-translate-ur="ڈارک موڈ">Dark Mode</button>
            <button id="export-data" data-translate-en="Export JSON" data-translate-ur="JSON ایکسپورٹ">Export JSON</button>
            <button id="import-data-btn" data-translate-en="Import JSON" data-translate-ur="JSON امپورٹ">Import JSON</button>
            <input type="file" id="import-file" accept=".json" class="hidden">
        </div>
    </header>

    <div class="container">
        <div id="status-area"></div>

        <div class="controls">
            <input type="search" id="search-input" placeholder="Search Name..." data-translate-placeholder-en="Search Name..." data-translate-placeholder-ur="نام تلاش کریں...">
            <select id="grade-filter">
                <option value="" data-translate-en="Filter by Grade..." data-translate-ur="درجہ کے لحاظ سے فلٹر کریں...">Filter by Grade...</option>
                <!-- Grade options will be populated dynamically -->
            </select>
             <select id="tag-filter">
                <option value="" data-translate-en="Filter by Tag..." data-translate-ur="ٹیگ کے لحاظ سے فلٹر کریں...">Filter by Tag...</option>
                <!-- Tag options will be populated dynamically -->
            </select>
            <select id="category-filter">
                <option value="" data-translate-en="Filter by Category..." data-translate-ur="زمرہ کے لحاظ سے فلٹر کریں...">Filter by Category...</option>
                 <!-- Category options will be populated dynamically -->
            </select>
            <button id="bookmarks-filter-btn" data-translate-en="Show Bookmarks" data-translate-ur="بک مارکس دکھائیں">Show Bookmarks</button>
            <button id="reset-filters-btn" data-translate-en="Reset Filters" data-translate-ur="فلٹرز ری سیٹ کریں">Reset Filters</button>
        </div>

        <div class="main-content">
            <div class="narrator-list-container">
                <h2 data-translate-en="Narrators" data-translate-ur="راوی">Narrators</h2>
                <ul id="narrator-list">
                    <!-- Narrator items will be populated here -->
                </ul>
                <div class="pagination" id="pagination-controls">
                    <button id="prev-page" data-translate-en="Previous" data-translate-ur="پچھلا">Previous</button>
                    <span id="page-info">Page 1 of 1</span>
                    <button id="next-page" data-translate-en="Next" data-translate-ur="اگلا">Next</button>
                </div>
            </div>

            <div class="details-and-viz-container">
                <div class="narrator-details" id="narrator-details">
                    <h2 data-translate-en="Details" data-translate-ur="تفصیلات">Details</h2>
                    <div id="details-content" data-translate-en="Select a narrator from the list." data-translate-ur="فہرست سے ایک راوی منتخب کریں۔">Select a narrator from the list.</div>
                     <!-- Bookmark and Notes Section -->
                    <div id="actions-section" class="hidden" style="margin-top: 1rem;">
                         <button id="bookmark-button" class="secondary"></button>
                         <h3 data-translate-en="Personal Notes" data-translate-ur="ذاتی نوٹس" style="margin-top: 1rem;">Personal Notes</h3>
                         <textarea id="notes-textarea" rows="4" data-translate-placeholder-en="Add your notes here..." data-translate-placeholder-ur="اپنے نوٹس یہاں شامل کریں..."></textarea>
                         <button id="save-note-button" style="margin-top: 0.5rem;" data-translate-en="Save Note" data-translate-ur="نوٹ محفوظ کریں">Save Note</button>
                    </div>
                </div>

                <div class="visualization-container" id="visualization-container">
                     <h2 data-translate-en="Relationship Graph" data-translate-ur="تعلقات کا گراف">Relationship Graph</h2>
                     <div style="margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 5px;">
                        <span data-translate-en="Zoom/Pan enabled. Click nodes." data-translate-ur="زوم/پین فعال ہے۔ نوڈز پر کلک کریں۔" style="font-size: 0.8em; color: var(--secondary-color);">Zoom/Pan enabled. Click nodes.</span>
                        <button id="print-viz-button" class="secondary" data-translate-en="Print Graph" data-translate-ur="گراف پرنٹ کریں">Print Graph</button>
                     </div>
                     <svg id="graph-svg"></svg>
                </div>

                 <div class="path-tracing-container" style="margin-top: 1rem; padding: 1rem; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--bg-color);">
                    <h2 data-translate-en="Relationship Path Tracer" data-translate-ur="تعلقات کا راستہ ٹریسر">Relationship Path Tracer</h2>
                    <div>
                        <label for="path-start-node" data-translate-en="Start Narrator:" data-translate-ur="شروعاتی راوی:">Start Narrator:</label>
                        <input type="text" id="path-start-node-search" placeholder="Search Start ID/Name..." data-translate-placeholder-en="Search Start ID/Name..." data-translate-placeholder-ur="شروعاتی ID/نام تلاش کریں...">
                        <span id="path-start-node-display"></span>
                        <input type="hidden" id="path-start-node">
                    </div>
                     <div style="margin-top: 0.5rem;">
                        <label for="path-end-node" data-translate-en="End Narrator:" data-translate-ur="اختتامی راوی:">End Narrator:</label>
                        <input type="text" id="path-end-node-search" placeholder="Search End ID/Name..." data-translate-placeholder-en="Search End ID/Name..." data-translate-placeholder-ur="اختتامی ID/نام تلاش کریں...">
                        <span id="path-end-node-display"></span>
                        <input type="hidden" id="path-end-node">
                    </div>
                    <button id="trace-path-button" style="margin-top: 0.5rem;" data-translate-en="Find Path" data-translate-ur="راستہ تلاش کریں">Find Path</button>
                    <div id="path-result" style="margin-top: 1rem; max-height: 150px; overflow-y: auto;"></div>
                </div>

            </div>
        </div>
    </div>

    <footer>
        <p style="text-align: center; margin-top: 1rem; font-size: 0.9em; color: var(--secondary-color);">
            App by Yasin Ullah (Pakistani)
        </p>
    </footer>

    <div id="loading-overlay" class="loading-overlay hidden">
        <div id="loading-message">Loading...</div>
        <progress id="loading-progress" max="100" value="0"></progress>
    </div>

    <script>
        // --- Configuration ---
        const DB_NAME = 'IsnadNarratorsDB';
        const DB_VERSION = 1;
        const NARRATORS_STORE = 'narrators';
        const BOOKMARKS_STORE = 'bookmarks';
        const NOTES_STORE = 'notes';
        const METADATA_STORE = 'metadata'; // To store info like load status, unique values
        const CSV_FILE_PATH = 'all_rawis.csv';
        const ITEMS_PER_PAGE = 25;

        // --- State Variables ---
        let db;
        let currentPage = 1;
        let totalPages = 1;
        let currentFilters = { search: '', grade: '', tag: '', category: '', bookmarkedOnly: false };
        let currentNarratorList = []; // Holds the IDs of narrators currently displayed
        let selectedNarratorId = null;
        let uniqueGrades = new Set();
        let uniqueTags = new Set();
        let uniqueCategories = new Set(); // From area_of_interest
        let currentLanguage = localStorage.getItem('language') || 'en';
        let currentTheme = localStorage.getItem('theme') || 'light';
        let isDragging = false;
        let startPoint = { x: 0, y: 0 };
        let currentViewBox = { x: 0, y: 0, width: 0, height: 0 }; // Initialized later
        let currentScale = 1;
        let graphData = { nodes: [], links: [] }; // For SVG graph
        let pathSearchCache = {}; // Simple cache for narrator lookups by name/id

        // --- DOM Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = document.getElementById('loading-message');
        const loadingProgress = document.getElementById('loading-progress');
        const narratorListEl = document.getElementById('narrator-list');
        const detailsContentEl = document.getElementById('details-content');
        const paginationControlsEl = document.getElementById('pagination-controls');
        const pageInfoEl = document.getElementById('page-info');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const searchInput = document.getElementById('search-input');
        const gradeFilter = document.getElementById('grade-filter');
        const tagFilter = document.getElementById('tag-filter');
        const categoryFilter = document.getElementById('category-filter');
        const bookmarksFilterBtn = document.getElementById('bookmarks-filter-btn');
        const resetFiltersBtn = document.getElementById('reset-filters-btn');
        const langToggleBtn = document.getElementById('lang-toggle');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const exportBtn = document.getElementById('export-data');
        const importBtn = document.getElementById('import-data-btn');
        const importFileEl = document.getElementById('import-file');
        const statusArea = document.getElementById('status-area');
        const graphSvg = document.getElementById('graph-svg');
        const graphContainer = document.getElementById('visualization-container');
        const printVizBtn = document.getElementById('print-viz-button');
        const actionsSection = document.getElementById('actions-section');
        const bookmarkButton = document.getElementById('bookmark-button');
        const notesTextarea = document.getElementById('notes-textarea');
        const saveNoteButton = document.getElementById('save-note-button');
        const pathStartSearch = document.getElementById('path-start-node-search');
        const pathEndSearch = document.getElementById('path-end-node-search');
        const pathStartDisplay = document.getElementById('path-start-node-display');
        const pathEndDisplay = document.getElementById('path-end-node-display');
        const pathStartNodeInput = document.getElementById('path-start-node');
        const pathEndNodeInput = document.getElementById('path-end-node');
        const tracePathButton = document.getElementById('trace-path-button');
        const pathResultEl = document.getElementById('path-result');


        // --- Translation Data ---
        const translations = {
            en: {
                "Loading...": "Loading...",
                "Processing CSV data (approx. {count} rows)...": "Processing CSV data (approx. {count} rows)...",
                "Storing data in database...": "Storing data in database...",
                "Database initialized. Loading narrators...": "Database initialized. Loading narrators...",
                "Error initializing database:": "Error initializing database:",
                "Error loading or processing CSV:": "Error loading or processing CSV:",
                "No narrators found matching your criteria.": "No narrators found matching your criteria.",
                "Select a narrator from the list.": "Select a narrator from the list.",
                "Page {current} of {total}": "Page {current} of {total}",
                "Previous": "Previous",
                "Next": "Next",
                "Search Name...": "Search Name...",
                "Filter by Grade...": "Filter by Grade...",
                "Filter by Tag...": "Filter by Tag...",
                "Filter by Category...": "Filter by Category...",
                "Show Bookmarks": "Show Bookmarks",
                "Show All": "Show All",
                "Reset Filters": "Reset Filters",
                "Details": "Details",
                "Relationship Graph": "Relationship Graph",
                "Zoom/Pan enabled. Click nodes.": "Zoom/Pan enabled. Click nodes.",
                "Print Graph": "Print Graph",
                "Export JSON": "Export JSON",
                "Import JSON": "Import JSON",
                "Data exported successfully as 'isnad_export.json'.": "Data exported successfully as 'isnad_export.json'.",
                "Error exporting data:": "Error exporting data:",
                "Importing data... This will replace existing data.": "Importing data... This will replace existing data.",
                "Import successful! Reloading data...": "Import successful! Reloading data...",
                "Error importing data:": "Error importing data:",
                "Invalid file format or corrupted data.": "Invalid file format or corrupted data.",
                "Please select a JSON file.": "Please select a JSON file.",
                "Dark Mode": "Dark Mode",
                "Light Mode": "Light Mode",
                "Isnad Narrators Explorer": "Isnad Narrators Explorer",
                "Narrators": "Narrators",
                "Grade": "Grade",
                "Parents": "Parents",
                "Spouse": "Spouse",
                "Siblings": "Siblings",
                "Children": "Children",
                "Birth Date/Place": "Birth Date/Place",
                "Places of Stay": "Places of Stay",
                "Death Date/Place": "Death Date/Place",
                "Teachers": "Teachers",
                "Students": "Students",
                "Area of Interest": "Area of Interest",
                "Tags": "Tags",
                "Books": "Books",
                "Bookmark": "Bookmark",
                "Remove Bookmark": "Remove Bookmark",
                "Personal Notes": "Personal Notes",
                "Add your notes here...": "Add your notes here...",
                "Save Note": "Save Note",
                "Note saved.": "Note saved.",
                "Error saving note:": "Error saving note:",
                "Relationship Path Tracer": "Relationship Path Tracer",
                "Start Narrator:": "Start Narrator:",
                "End Narrator:": "End Narrator:",
                "Search Start ID/Name...": "Search Start ID/Name...",
                "Search End ID/Name...": "Search End ID/Name...",
                "Find Path": "Find Path",
                "Path found:": "Path found:",
                "No path found between the selected narrators.": "No path found between the selected narrators.",
                "Error finding path:": "Error finding path:",
                "Please select both start and end narrators.": "Please select both start and end narrators.",
                "Narrator not found:": "Narrator not found:",
                "Loading narrator data...": "Loading narrator data...",
                "Error loading narrator data:": "Error loading narrator data:",
                "Data loaded successfully.": "Data loaded successfully.",
                "Initializing application...": "Initializing application...",
                "Database already populated.": "Database already populated.",
                "Fetching CSV file...": "Fetching CSV file...",
                "CSV file fetched. Size: {size} bytes": "CSV file fetched. Size: {size} bytes",
                "Parsing CSV...": "Parsing CSV...",
                "CSV parsed. {count} records found.": "CSV parsed. {count} records found.",
                "Populating unique filters...": "Populating unique filters...",
                "Unique filters populated.": "Unique filters populated.",
                "Error during data loading pipeline:": "Error during data loading pipeline:",
                "IndexedDB not supported by this browser.": "IndexedDB not supported by this browser.",
                "Data integrity check failed. Reloading might be needed.": "Data integrity check failed. Reloading might be needed.",
                "No details available.": "No details available.",
                "N/A": "N/A",
                "Click to view": "Click to view",
                "Loading graph...": "Loading graph...",
                "Error loading graph:": "Error loading graph:",
                "Graph loaded.": "Graph loaded.",
                "Clearing existing data...": "Clearing existing data...",
                "Importing narrators ({count})...": "Importing narrators ({count})...",
                "Importing bookmarks ({count})...": "Importing bookmarks ({count})...",
                "Importing notes ({count})...": "Importing notes ({count})...",
                "Importing metadata...": "Importing metadata...",
                "Data import complete.": "Data import complete.",
                "Error during import transaction:": "Error during import transaction:",
                "Exporting data...": "Exporting data...",
                "Export complete.": "Export complete.",
                "Error during export:": "Error during export:",
                "Finding path...": "Finding path...",
                "Error: Start or end narrator not found in database.": "Error: Start or end narrator not found in database.",
                "Path Trace (via Teachers/Students):": "Path Trace (via Teachers/Students):",
                "Direct Connection": "Direct Connection",
                "No Connection Found": "No Connection Found",
                "Error during pathfinding:": "Error during pathfinding:",
                "Saving note...": "Saving note...",
                "Error saving note:": "Error saving note:",
                "Note saved successfully.": "Note saved successfully.",
                "Loading note...": "Loading note...",
                "Error loading note:": "Error loading note:",
                "Updating bookmark...": "Updating bookmark...",
                "Error updating bookmark:": "Error updating bookmark:",
                "Bookmark status updated.": "Bookmark status updated.",
                "Loading bookmarks...": "Loading bookmarks...",
                "Error loading bookmarks:": "Error loading bookmarks:",
                "Loading narrator details...": "Loading narrator details...",
                "Error loading narrator details:": "Error loading narrator details:",
                "Loading narrator list...": "Loading narrator list...",
                "Error loading narrator list:": "Error loading narrator list:",
                "Populating filter options...": "Populating filter options...",
                "Error populating filters:": "Error populating filters:",
                "Filter options populated.": "Filter options populated.",
                "Initializing database connection...": "Initializing database connection...",
                "Database connection successful.": "Database connection successful.",
                "Checking data status...": "Checking data status...",
                "Data status checked.": "Data status checked.",
                "Error checking data status:": "Error checking data status:",
                "Data needs to be loaded from CSV.": "Data needs to be loaded from CSV.",
                "Starting data load process...": "Starting data load process...",
                "Data load process completed.": "Data load process completed.",
                "Error during initial data load:": "Error during initial data load:",
                "Application Ready.": "Application Ready.",
                "ID": "ID",
                "Name": "Name",
                "Birth": "Birth",
                "Death": "Death",
                "Teachers Inds": "Teachers Inds",
                "Students Inds": "Students Inds",
                "Birth Place": "Birth Place",
                "Birth Date": "Birth Date",
                "Birth Date Hijri": "Birth Date Hijri",
                "Birth Date Gregorian": "Birth Date Gregorian",
                "Death Date Hijri": "Death Date Hijri",
                "Death Date Gregorian": "Death Date Gregorian",
                "Death Place": "Death Place",
                "Death Reason": "Death Reason",
                "Unknown": "Unknown",
                "Natural": "Natural",
                "Martyred": "Martyred",
                "Loading": "Loading",
                "Error": "Error",
                "Success": "Success",
                "Warning": "Warning",
                "Info": "Info",
                "Confirm": "Confirm",
                "Cancel": "Cancel",
                "Close": "Close",
                "Yes": "Yes",
                "No": "No",
                "OK": "OK",
                "Apply": "Apply",
                "Reset": "Reset",
                "Add": "Add",
                "Edit": "Edit",
                "Delete": "Delete",
                "Save": "Save",
                "Search": "Search",
                "Filter": "Filter",
                "Sort": "Sort",
                "View": "View",
                "Hide": "Hide",
                "Show": "Show",
                "Clear": "Clear",
                "Copy": "Copy",
                "Paste": "Paste",
                "Cut": "Cut",
                "Undo": "Undo",
                "Redo": "Redo",
                "Select All": "Select All",
                "Deselect All": "Deselect All",
                "Refresh": "Refresh",
                "Help": "Help",
                "About": "About",
                "Settings": "Settings",
                "Preferences": "Preferences",
                "Options": "Options",
                "Tools": "Tools",
                "File": "File",
                "New": "New",
                "Open": "Open",
                "Print": "Print",
                "Exit": "Exit",
                "Window": "Window",
                "Minimize": "Minimize",
                "Maximize": "Maximize",
                "Restore": "Restore",
                "Full Screen": "Full Screen",
                "Toggle Developer Tools": "Toggle Developer Tools",
                "Reload": "Reload",
                "Force Reload": "Force Reload",
                "Zoom In": "Zoom In",
                "Zoom Out": "Zoom Out",
                "Reset Zoom": "Reset Zoom",
                "Go Back": "Go Back",
                "Go Forward": "Go Forward",
                "Home": "Home",
                "End": "End",
                "Page Up": "Page Up",
                "Page Down": "Page Down",
                "Scroll Up": "Scroll Up",
                "Scroll Down": "Scroll Down",
                "Scroll Left": "Scroll Left",
                "Scroll Right": "Scroll Right",
                "Jump to Top": "Jump to Top",
                "Jump to Bottom": "Jump to Bottom",
                "Loading data from IndexedDB...": "Loading data from IndexedDB...",
                "Error loading data from IndexedDB:": "Error loading data from IndexedDB:",
                "Data loaded. Rendering UI...": "Data loaded. Rendering UI...",
                "UI rendered.": "UI rendered.",
                "Error rendering UI:": "Error rendering UI:",
                "Updating language...": "Updating language...",
                "Language updated.": "Language updated.",
                "Updating theme...": "Updating theme...",
                "Theme updated.": "Theme updated.",
                "Applying filters...": "Applying filters...",
                "Filters applied.": "Filters applied.",
                "Error applying filters:": "Error applying filters:",
                "Resetting filters...": "Resetting filters...",
                "Filters reset.": "Filters reset.",
                "Navigating page...": "Navigating page...",
                "Page navigated.": "Page navigated.",
                "Error navigating page:": "Error navigating page:",
                "Displaying narrator details...": "Displaying narrator details...",
                "Details displayed.": "Details displayed.",
                "Error displaying details:": "Error displaying details:",
                "Updating graph...": "Updating graph...",
                "Graph updated.": "Graph updated.",
                "Error updating graph:": "Error updating graph:",
                "Printing graph...": "Printing graph...",
                "Graph print initiated.": "Graph print initiated.",
                "Error initiating print:": "Error initiating print:",
                "Searching narrator for path...": "Searching narrator for path...",
                "Narrator found for path.": "Narrator found for path.",
                "Error searching narrator for path:": "Error searching narrator for path:",
                "Confirm Import": "Confirm Import",
                "Are you sure you want to import data? This will overwrite all existing narrators, bookmarks, and notes.": "Are you sure you want to import data? This will overwrite all existing narrators, bookmarks, and notes.",
                "Import Cancelled.": "Import Cancelled.",
                "Confirm Reset": "Confirm Reset",
                "Are you sure you want to reset all filters?": "Are you sure you want to reset all filters?",
                "Reset Cancelled.": "Reset Cancelled.",
                "Confirm Delete Note": "Confirm Delete Note",
                "Are you sure you want to delete the note for this narrator? This cannot be undone.": "Are you sure you want to delete the note for this narrator? This cannot be undone.",
                "Delete Cancelled.": "Delete Cancelled.",
                "Note deleted.": "Note deleted.",
                "Error deleting note:": "Error deleting note:",
                "Delete Note": "Delete Note", // Added for button text
                "No": "No", // Added for confirmation
                "Yes": "Yes", // Added for confirmation
                "Confirm Action": "Confirm Action", // Generic confirmation title
                "Operation cancelled.": "Operation cancelled.", // Generic cancellation message
                "Processing...": "Processing...", // Generic processing message
                "Completed.": "Completed.", // Generic completion message
                "Failed:": "Failed:", // Generic failure prefix
                "Success:": "Success:", // Generic success prefix
                "Warning:": "Warning:", // Generic warning prefix
                "Information:": "Information:", // Generic info prefix
                "Invalid Input": "Invalid Input", // For validation errors
                "Value cannot be empty.": "Value cannot be empty.", // Example validation message
                "Invalid ID format.": "Invalid ID format.", // Example validation message
                "Item not found.": "Item not found.", // Generic not found message
                "Database error:": "Database error:", // Generic DB error prefix
                "Network error:": "Network error:", // Generic network error prefix
                "File error:": "File error:", // Generic file error prefix
                "Parsing error:": "Parsing error:", // Generic parsing error prefix
                "Unknown error:": "Unknown error:", // Catch-all error prefix
                "Please wait...": "Please wait...", // Waiting message
                "Ready.": "Ready.", // Idle state message
                "Saving settings...": "Saving settings...",
                "Settings saved.": "Settings saved.",
                "Error saving settings:": "Error saving settings:",
                "Loading settings...": "Loading settings...",
                "Settings loaded.": "Settings loaded.",
                "Error loading settings:": "Error loading settings:",
                "Default settings applied.": "Default settings applied.",
                "Confirm Reset Settings": "Confirm Reset Settings",
                "Are you sure you want to reset all settings to their defaults?": "Are you sure you want to reset all settings to their defaults?",
                "Settings reset cancelled.": "Settings reset cancelled.",
                "Settings reset to default.": "Settings reset to default.",
                "Error resetting settings:": "Error resetting settings:",
                "Reset Settings": "Reset Settings",
                "Author: Yasin Ullah (Pakistani)": "Author: Yasin Ullah (Pakistani)",
                "App Version: {version}": "App Version: {version}", // Example version display
                "Data Source: {source}": "Data Source: {source}", // Example data source display
                "Total Narrators: {count}": "Total Narrators: {count}", // Example stats display
                "Bookmarked: {count}": "Bookmarked: {count}", // Example stats display
                "Notes Added: {count}": "Notes Added: {count}", // Example stats display
                "Last Updated: {date}": "Last Updated: {date}", // Example metadata display
                "Database Status: {status}": "Database Status: {status}", // Example status display
                "Online": "Online", // Network status
                "Offline": "Offline", // Network status
                "Connected": "Connected", // DB status
                "Disconnected": "Disconnected", // DB status
                "Loading": "Loading", // Status
                "Idle": "Idle", // Status
                "Busy": "Busy", // Status
                "Error": "Error", // Status
                "Not Initialized": "Not Initialized", // Status
                "Data Available": "Data Available", // Status
                "No Data": "No Data", // Status
                "Requires Load": "Requires Load", // Status
                "Data Loading": "Data Loading", // Status
                "Data Ready": "Data Ready", // Status
                "Exporting...": "Exporting...",
                "Importing...": "Importing...",
                "Clearing Data...": "Clearing Data...",
                "Verifying Data...": "Verifying Data...",
                "Verification Complete.": "Verification Complete.",
                "Verification Failed.": "Verification Failed.",
                "Backup Recommended": "Backup Recommended",
                "Consider exporting your data regularly as a backup.": "Consider exporting your data regularly as a backup.",
                "Backup & Restore": "Backup & Restore",
                "Use Export/Import JSON buttons for backup and restore operations.": "Use Export/Import JSON buttons for backup and restore operations.",
                "Data Integrity Check": "Data Integrity Check",
                "Running data integrity check...": "Running data integrity check...",
                "Integrity check passed.": "Integrity check passed.",
                "Integrity check failed. Issues found: {issues}": "Integrity check failed. Issues found: {issues}",
                "Attempting repair...": "Attempting repair...",
                "Repair successful.": "Repair successful.",
                "Repair failed. Manual intervention may be required.": "Repair failed. Manual intervention may be required.",
                "Check Console": "Check Console",
                "Check the browser console (F12) for detailed error messages.": "Check the browser console (F12) for detailed error messages.",
                "Report Bug": "Report Bug",
                "If you encounter persistent issues, please report the bug with details.": "If you encounter persistent issues, please report the bug with details.",
                "System Information": "System Information",
                "Browser: {browser}": "Browser: {browser}",
                "OS: {os}": "OS: {os}",
                "Screen Resolution: {resolution}": "Screen Resolution: {resolution}",
                "Memory Usage: {memory}": "Memory Usage: {memory}",
                "Performance Metrics": "Performance Metrics",
                "Load Time: {time} ms": "Load Time: {time} ms",
                "Query Time: {time} ms": "Query Time: {time} ms",
                "Render Time: {time} ms": "Render Time: {time} ms",
                "Graph Render Time: {time} ms": "Graph Render Time: {time} ms",
                "Pathfind Time: {time} ms": "Pathfind Time: {time} ms",
                "Memory Peak: {memory} MB": "Memory Peak: {memory} MB",
                "Optimization Tips": "Optimization Tips",
                "Use filters to narrow down results for faster loading.": "Use filters to narrow down results for faster loading.",
                "Keep the number of simultaneously displayed graph nodes manageable.": "Keep the number of simultaneously displayed graph nodes manageable.",
                "Ensure sufficient disk space for IndexedDB storage.": "Ensure sufficient disk space for IndexedDB storage.",
                "Clear browser cache if experiencing persistent slowness.": "Clear browser cache if experiencing persistent slowness.",
                "Consider using a modern browser for best performance.": "Consider using a modern browser for best performance.",
                "Accessibility Features": "Accessibility Features",
                "Keyboard Navigation: Use Tab/Shift+Tab, Enter/Space, Arrow Keys.": "Keyboard Navigation: Use Tab/Shift+Tab, Enter/Space, Arrow Keys.",
                "Screen Reader Support: Basic ARIA roles and labels implemented.": "Screen Reader Support: Basic ARIA roles and labels implemented.",
                "High Contrast Mode: Follows system/browser high contrast settings where possible.": "High Contrast Mode: Follows system/browser high contrast settings where possible.",
                "Text Resizing: UI should adapt to browser text size adjustments.": "Text Resizing: UI should adapt to browser text size adjustments.",
                "Feedback Welcome": "Feedback Welcome",
                "Your feedback is valuable for improving this tool.": "Your feedback is valuable for improving this tool.",
                "Contact": "Contact",
                "For support or feedback, contact the author.": "For support or feedback, contact the author.",
                "License Information": "License Information",
                "This software is provided 'as-is' without warranty. Use at your own risk.": "This software is provided 'as-is' without warranty. Use at your own risk.",
                "Source Code": "Source Code",
                "Source code might be available upon request or repository link.": "Source code might be available upon request or repository link.",
                "Acknowledgements": "Acknowledgements",
                "Data sourced from [Specify Source if known].": "Data sourced from [Specify Source if known].",
                "Built with Vanilla JS and IndexedDB.": "Built with Vanilla JS and IndexedDB.",
                "Special thanks to the Islamic scholarship community.": "Special thanks to the Islamic scholarship community.",
                "Privacy Policy": "Privacy Policy",
                "All data is stored locally in your browser's IndexedDB. No data is sent to any server.": "All data is stored locally in your browser's IndexedDB. No data is sent to any server.",
                "Clearing browser data will remove all stored information.": "Clearing browser data will remove all stored information.",
                "Use the Export feature to create backups.": "Use the Export feature to create backups.",
                "Terms of Service": "Terms of Service",
                "Refer to License Information.": "Refer to License Information.",
                "User Guide": "User Guide",
                "Loading Data: Data from '{csv}' is loaded into the browser database on first run.": "Loading Data: Data from '{csv}' is loaded into the browser database on first run.",
                "Searching/Filtering: Use the controls above the list to find specific narrators.": "Searching/Filtering: Use the controls above the list to find specific narrators.",
                "Viewing Details: Click a narrator in the list or graph to see their details.": "Viewing Details: Click a narrator in the list or graph to see their details.",
                "Navigation: Clickable links (IDs) in details navigate to related narrators.": "Navigation: Clickable links (IDs) in details navigate to related narrators.",
                "Graph: Shows relationships (Teachers/Students). Use mouse wheel to zoom, click-and-drag to pan.": "Graph: Shows relationships (Teachers/Students). Use mouse wheel to zoom, click-and-drag to pan.",
                "Bookmarks/Notes: Save narrators or add personal notes in the details panel.": "Bookmarks/Notes: Save narrators or add personal notes in the details panel.",
                "Path Tracing: Find connection paths between two narrators using the tracer tool.": "Path Tracing: Find connection paths between two narrators using the tracer tool.",
                "Export/Import: Backup your data (including notes/bookmarks) or restore from a backup using the JSON buttons in the header.": "Export/Import: Backup your data (including notes/bookmarks) or restore from a backup using the JSON buttons in the header.",
                "Language/Theme: Toggle between English/Urdu and Light/Dark modes using header buttons.": "Language/Theme: Toggle between English/Urdu and Light/Dark modes using header buttons.",
                "Printing: Use the 'Print Graph' button to print the current visualization.": "Printing: Use the 'Print Graph' button to print the current visualization.",
                "Troubleshooting": "Troubleshooting",
                "If data doesn't load, ensure '{csv}' is in the same directory and check browser console (F12) for errors.": "If data doesn't load, ensure '{csv}' is in the same directory and check browser console (F12) for errors.",
                "If the app is slow, try resetting filters or restarting the browser.": "If the app is slow, try resetting filters or restarting the browser.",
                "Import errors usually mean the JSON file is invalid or corrupted.": "Import errors usually mean the JSON file is invalid or corrupted.",
                "Ensure you have enough disk space for IndexedDB.": "Ensure you have enough disk space for IndexedDB.",
                "Contact author for persistent issues.": "Contact author for persistent issues.",
                "Feature Roadmap (Potential Future Ideas)": "Feature Roadmap (Potential Future Ideas)",
                "Advanced Graph Layouts": "Advanced Graph Layouts",
                "Timeline Visualization": "Timeline Visualization",
                "Geographical Mapping": "Geographical Mapping",
                "Statistical Analysis": "Statistical Analysis",
                "User Accounts (Server-based - NOT CURRENTLY PLANNED)": "User Accounts (Server-based - NOT CURRENTLY PLANNED)",
                "Collaborative Features (Server-based - NOT CURRENTLY PLANNED)": "Collaborative Features (Server-based - NOT CURRENTLY PLANNED)",
                "More Data Sources Integration": "More Data Sources Integration",
                "Enhanced Search Capabilities (e.g., fuzzy search, boolean logic)": "Enhanced Search Capabilities (e.g., fuzzy search, boolean logic)",
                "Customizable UI Themes": "Customizable UI Themes",
                "Offline Mode Improvements (Service Worker - currently excluded)": "Offline Mode Improvements (Service Worker - currently excluded)",
                "Mobile App Version (Native)": "Mobile App Version (Native)",
                "API for External Tools": "API for External Tools",
                "Integration with Hadith Databases": "Integration with Hadith Databases",
                "Automated Data Validation/Cleaning Tools": "Automated Data Validation/Cleaning Tools",
                "Version History / Changelog": "Version History / Changelog",
                "Initial Release (v1.0): Core features implemented.": "Initial Release (v1.0): Core features implemented.",
                "Known Issues": "Known Issues",
                "Graph performance may degrade with very large numbers of nodes displayed simultaneously.": "Graph performance may degrade with very large numbers of nodes displayed simultaneously.",
                "Complex CSV parsing (nested quotes/escapes) might have edge cases.": "Complex CSV parsing (nested quotes/escapes) might have edge cases.",
                "RTL text rendering in SVG might vary slightly across browsers.": "RTL text rendering in SVG might vary slightly across browsers.",
                "Pathfinding for very distant narrators can be slow.": "Pathfinding for very distant narrators can be slow.",
                "Print styling might need adjustments based on browser.": "Print styling might need adjustments based on browser.",
                "Memory usage can be high during initial data load or large exports.": "Memory usage can be high during initial data load or large exports.",
                "No Service Worker for offline caching (as per requirement).": "No Service Worker for offline caching (as per requirement).",
                "Dependencies: None (except web fonts if used by browser/OS).": "Dependencies: None (except web fonts if used by browser/OS).",
                "Compatibility: Modern browsers (Chrome, Firefox, Edge, Safari) supporting IndexedDB, ES6+.": "Compatibility: Modern browsers (Chrome, Firefox, Edge, Safari) supporting IndexedDB, ES6+.",
                "Data Accuracy Disclaimer": "Data Accuracy Disclaimer",
                "The accuracy of the narrator data depends entirely on the source CSV file.": "The accuracy of the narrator data depends entirely on the source CSV file.",
                "This tool is for exploration and visualization; verify critical information with primary sources.": "This tool is for exploration and visualization; verify critical information with primary sources.",
                "Report any data inaccuracies to the source provider if possible.": "Report any data inaccuracies to the source provider if possible.",
                "The author of this tool is not responsible for data errors in the source file.": "The author of this tool is not responsible for data errors in the source file.",
                "Final Note": "Final Note",
                "This application aims to be a helpful tool for researchers and students of Isnad.": "This application aims to be a helpful tool for researchers and students of Isnad.",
                "Developed with care by Yasin Ullah.": "Developed with care by Yasin Ullah.",
                "Feedback and contributions (if applicable) are welcome.": "Feedback and contributions (if applicable) are welcome.",
                "May this tool benefit your studies.": "May this tool benefit your studies.",
                "Allah knows best.": "Allah knows best.",
            },
            ur: {
                "Loading...": "لوڈ ہو رہا ہے۔۔۔",
                "Processing CSV data (approx. {count} rows)...": "CSV ڈیٹا پر کارروائی ہو رہی ہے (تقریباً {count} قطاریں)...",
                "Storing data in database...": "ڈیٹا بیس میں ڈیٹا ذخیرہ کیا جا رہا ہے۔۔۔",
                "Database initialized. Loading narrators...": "ڈیٹا بیس شروع ہو گیا۔ راوی لوڈ ہو رہے ہیں۔۔۔",
                "Error initializing database:": "ڈیٹا بیس شروع کرنے میں خرابی:",
                "Error loading or processing CSV:": "CSV لوڈ کرنے یا پروسیس کرنے میں خرابی:",
                "No narrators found matching your criteria.": "آپ کے معیار کے مطابق کوئی راوی نہیں ملا۔",
                "Select a narrator from the list.": "فہرست سے ایک راوی منتخب کریں۔",
                "Page {current} of {total}": "صفحہ {current} از {total}",
                "Previous": "پچھلا",
                "Next": "اگلا",
                "Search Name...": "نام تلاش کریں...",
                "Filter by Grade...": "درجہ کے لحاظ سے فلٹر کریں...",
                "Filter by Tag...": "ٹیگ کے لحاظ سے فلٹر کریں...",
                "Filter by Category...": "زمرہ کے لحاظ سے فلٹر کریں...",
                "Show Bookmarks": "بک مارکس دکھائیں",
                "Show All": "سب دکھائیں",
                "Reset Filters": "فلٹرز ری سیٹ کریں",
                "Details": "تفصیلات",
                "Relationship Graph": "تعلقات کا گراف",
                "Zoom/Pan enabled. Click nodes.": "زوم/پین فعال ہے۔ نوڈز پر کلک کریں۔",
                "Print Graph": "گراف پرنٹ کریں",
                "Export JSON": "JSON ایکسپورٹ",
                "Import JSON": "JSON امپورٹ",
                "Data exported successfully as 'isnad_export.json'.": "ڈیٹا کامیابی کے ساتھ 'isnad_export.json' کے طور پر ایکسپورٹ ہو گیا۔",
                "Error exporting data:": "ڈیٹا ایکسپورٹ کرنے میں خرابی:",
                "Importing data... This will replace existing data.": "ڈیٹا امپورٹ کیا جا رہا ہے... یہ موجودہ ڈیٹا کو بدل دے گا۔",
                "Import successful! Reloading data...": "امپورٹ کامیاب! ڈیٹا دوبارہ لوڈ کیا جا رہا ہے۔۔۔",
                "Error importing data:": "ڈیٹا امپورٹ کرنے میں خرابی:",
                "Invalid file format or corrupted data.": "غلط فائل فارمیٹ یا خراب ڈیٹا۔",
                "Please select a JSON file.": "براہ کرم ایک JSON فائل منتخب کریں۔",
                "Dark Mode": "ڈارک موڈ",
                "Light Mode": "لائٹ موڈ",
                "Isnad Narrators Explorer": "اسناد راوی ایکسپلورر",
                "Narrators": "راوی",
                "Grade": "درجہ",
                "Parents": "والدین",
                "Spouse": "شریک حیات",
                "Siblings": "بہن بھائی",
                "Children": "اولاد",
                "Birth Date/Place": "تاریخ/جائے پیدائش",
                "Places of Stay": "مقامات قیام",
                "Death Date/Place": "تاریخ/جائے وفات",
                "Teachers": "اساتذہ",
                "Students": "تلامذہ",
                "Area of Interest": "دلچسپی کا شعبہ",
                "Tags": "ٹیگز",
                "Books": "کتب",
                "Bookmark": "بک مارک",
                "Remove Bookmark": "بک مارک ہٹائیں",
                "Personal Notes": "ذاتی نوٹس",
                "Add your notes here...": "اپنے نوٹس یہاں شامل کریں...",
                "Save Note": "نوٹ محفوظ کریں",
                "Note saved.": "نوٹ محفوظ ہو گیا۔",
                "Error saving note:": "نوٹ محفوظ کرنے میں خرابی:",
                "Relationship Path Tracer": "تعلقات کا راستہ ٹریسر",
                "Start Narrator:": "شروعاتی راوی:",
                "End Narrator:": "اختتامی راوی:",
                "Search Start ID/Name...": "شروعاتی ID/نام تلاش کریں...",
                "Search End ID/Name...": "اختتامی ID/نام تلاش کریں...",
                "Find Path": "راستہ تلاش کریں",
                "Path found:": "راستہ مل گیا:",
                "No path found between the selected narrators.": "منتخب راویوں کے درمیان کوئی راستہ نہیں ملا۔",
                "Error finding path:": "راستہ تلاش کرنے میں خرابی:",
                "Please select both start and end narrators.": "براہ کرم شروع اور اختتامی دونوں راوی منتخب کریں۔",
                "Narrator not found:": "راوی نہیں ملا:",
                "Loading narrator data...": "راوی کا ڈیٹا لوڈ ہو رہا ہے۔۔۔",
                "Error loading narrator data:": "راوی کا ڈیٹا لوڈ کرنے میں خرابی:",
                "Data loaded successfully.": "ڈیٹا کامیابی سے لوڈ ہو گیا۔",
                "Initializing application...": "ایپلیکیشن شروع کی جا رہی ہے۔۔۔",
                "Database already populated.": "ڈیٹا بیس پہلے سے بھرا ہوا ہے۔",
                "Fetching CSV file...": "CSV فائل حاصل کی جا رہی ہے۔۔۔",
                "CSV file fetched. Size: {size} bytes": "CSV فائل حاصل ہو گئی۔ سائز: {size} بائٹس",
                "Parsing CSV...": "CSV پارس کیا جا رہا ہے۔۔۔",
                "CSV parsed. {count} records found.": "CSV پارس ہو گیا۔ {count} ریکارڈز ملے۔",
                "Populating unique filters...": "منفرد فلٹرز بنائے جا رہے ہیں۔۔۔",
                "Unique filters populated.": "منفرد فلٹرز بن گئے۔",
                "Error during data loading pipeline:": "ڈیٹا لوڈنگ پائپ لائن کے دوران خرابی:",
                "IndexedDB not supported by this browser.": "یہ براؤزر IndexedDB کو سپورٹ نہیں کرتا۔",
                "Data integrity check failed. Reloading might be needed.": "ڈیٹا انٹیگریٹی چیک ناکام ہو گیا۔ دوبارہ لوڈ کرنے کی ضرورت ہو سکتی ہے۔",
                "No details available.": "کوئی تفصیلات دستیاب نہیں۔",
                "N/A": "غیر دستیاب",
                "Click to view": "دیکھنے کے لیے کلک کریں",
                "Loading graph...": "گراف لوڈ ہو رہا ہے۔۔۔",
                "Error loading graph:": "گراف لوڈ کرنے میں خرابی:",
                "Graph loaded.": "گراف لوڈ ہو گیا۔",
                "Clearing existing data...": "موجودہ ڈیٹا صاف کیا جا رہا ہے۔۔۔",
                "Importing narrators ({count})...": "راوی امپورٹ ہو رہے ہیں ({count})...",
                "Importing bookmarks ({count})...": "بک مارکس امپورٹ ہو رہے ہیں ({count})...",
                "Importing notes ({count})...": "نوٹس امپورٹ ہو رہے ہیں ({count})...",
                "Importing metadata...": "میٹا ڈیٹا امپورٹ ہو رہا ہے۔۔۔",
                "Data import complete.": "ڈیٹا امپورٹ مکمل ہو گیا۔",
                "Error during import transaction:": "امپورٹ ٹرانزیکشن کے دوران خرابی:",
                "Exporting data...": "ڈیٹا ایکسپورٹ کیا جا رہا ہے۔۔۔",
                "Export complete.": "ایکسپورٹ مکمل ہو گیا۔",
                "Error during export:": "ایکسپورٹ کے دوران خرابی:",
                "Finding path...": "راستہ تلاش کیا جا رہا ہے۔۔۔",
                "Error: Start or end narrator not found in database.": "خرابی: شروع یا اختتامی راوی ڈیٹا بیس میں نہیں ملا۔",
                "Path Trace (via Teachers/Students):": "راستے کا سراغ (بذریعہ اساتذہ/تلامذہ):",
                "Direct Connection": "براہ راست تعلق",
                "No Connection Found": "کوئی تعلق نہیں ملا",
                "Error during pathfinding:": "راستہ تلاش کرنے کے دوران خرابی:",
                "Saving note...": "نوٹ محفوظ کیا جا رہا ہے۔۔۔",
                "Error saving note:": "نوٹ محفوظ کرنے میں خرابی:",
                "Note saved successfully.": "نوٹ کامیابی سے محفوظ ہو گیا۔",
                "Loading note...": "نوٹ لوڈ ہو رہا ہے۔۔۔",
                "Error loading note:": "نوٹ لوڈ کرنے میں خرابی:",
                "Updating bookmark...": "بک مارک اپ ڈیٹ کیا جا رہا ہے۔۔۔",
                "Error updating bookmark:": "بک مارک اپ ڈیٹ کرنے میں خرابی:",
                "Bookmark status updated.": "بک مارک کی حیثیت اپ ڈیٹ ہو گئی۔",
                "Loading bookmarks...": "بک مارکس لوڈ ہو رہے ہیں۔۔۔",
                "Error loading bookmarks:": "بک مارکس لوڈ کرنے میں خرابی:",
                "Loading narrator details...": "راوی کی تفصیلات لوڈ ہو رہی ہیں۔۔۔",
                "Error loading narrator details:": "راوی کی تفصیلات لوڈ کرنے میں خرابی:",
                "Loading narrator list...": "راویوں کی فہرست لوڈ ہو رہی ہے۔۔۔",
                "Error loading narrator list:": "راویوں کی فہرست لوڈ کرنے میں خرابی:",
                "Populating filter options...": "فلٹر کے اختیارات بنائے جا رہے ہیں۔۔۔",
                "Error populating filters:": "فلٹرز بنانے میں خرابی:",
                "Filter options populated.": "فلٹر کے اختیارات بن گئے۔",
                "Initializing database connection...": "ڈیٹا بیس کنکشن شروع کیا جا رہا ہے۔۔۔",
                "Database connection successful.": "ڈیٹا بیس کنکشن کامیاب۔",
                "Checking data status...": "ڈیٹا کی حیثیت چیک کی جا رہی ہے۔۔۔",
                "Data status checked.": "ڈیٹا کی حیثیت چیک ہو گئی۔",
                "Error checking data status:": "ڈیٹا کی حیثیت چیک کرنے میں خرابی:",
                "Data needs to be loaded from CSV.": "CSV سے ڈیٹا لوڈ کرنے کی ضرورت ہے۔",
                "Starting data load process...": "ڈیٹا لوڈ کا عمل شروع کیا جا رہا ہے۔۔۔",
                "Data load process completed.": "ڈیٹا لوڈ کا عمل مکمل ہو گیا۔",
                "Error during initial data load:": "ابتدائی ڈیٹا لوڈ کے دوران خرابی:",
                "Application Ready.": "ایپلیکیشن تیار ہے۔",
                "ID": "شناخت",
                "Name": "نام",
                "Birth": "پیدائش",
                "Death": "وفات",
                "Teachers Inds": "اساتذہ IDs",
                "Students Inds": "تلامذہ IDs",
                "Birth Place": "جائے پیدائش",
                "Birth Date": "تاریخ پیدائش",
                "Birth Date Hijri": "تاریخ پیدائش ہجری",
                "Birth Date Gregorian": "تاریخ پیدائش عیسوی",
                "Death Date Hijri": "تاریخ وفات ہجری",
                "Death Date Gregorian": "تاریخ وفات عیسوی",
                "Death Place": "جائے وفات",
                "Death Reason": "وجہ وفات",
                "Unknown": "نامعلوم",
                "Natural": "طبعی",
                "Martyred": "شہید",
                "Loading": "لوڈ ہو رہا ہے",
                "Error": "خرابی",
                "Success": "کامیابی",
                "Warning": "انتباہ",
                "Info": "معلومات",
                "Confirm": "تصدیق کریں",
                "Cancel": "منسوخ کریں",
                "Close": "بند کریں",
                "Yes": "ہاں",
                "No": "نہیں",
                "OK": "ٹھیک ہے",
                "Apply": "لاگو کریں",
                "Reset": "ری سیٹ",
                "Add": "شامل کریں",
                "Edit": "ترمیم کریں",
                "Delete": "حذف کریں",
                "Save": "محفوظ کریں",
                "Search": "تلاش",
                "Filter": "فلٹر",
                "Sort": "ترتیب دیں",
                "View": "دیکھیں",
                "Hide": "چھپائیں",
                "Show": "دکھائیں",
                "Clear": "صاف کریں",
                "Copy": "کاپی",
                "Paste": "پیسٹ",
                "Cut": "کٹ",
                "Undo": "کالعدم",
                "Redo": "دوبارہ کریں",
                "Select All": "سب منتخب کریں",
                "Deselect All": "سب غیر منتخب کریں",
                "Refresh": "ریفریش",
                "Help": "مدد",
                "About": "متعلق",
                "Settings": "ترتیبات",
                "Preferences": "ترجیحات",
                "Options": "اختیارات",
                "Tools": "آلات",
                "File": "فائل",
                "New": "نیا",
                "Open": "کھولیں",
                "Print": "پرنٹ",
                "Exit": "باہر نکلیں",
                "Window": "ونڈو",
                "Minimize": "چھوٹا کریں",
                "Maximize": "بڑا کریں",
                "Restore": "بحال کریں",
                "Full Screen": "پوری سکرین",
                "Toggle Developer Tools": "ڈیولپر ٹولز ٹوگل کریں",
                "Reload": "دوبارہ لوڈ کریں",
                "Force Reload": "زبردستی دوبارہ لوڈ کریں",
                "Zoom In": "بڑا کریں",
                "Zoom Out": "چھوٹا کریں",
                "Reset Zoom": "زوم ری سیٹ کریں",
                "Go Back": "پیچھے جائیں",
                "Go Forward": "آگے جائیں",
                "Home": "شروع",
                "End": "آخر",
                "Page Up": "صفحہ اوپر",
                "Page Down": "صفحہ نیچے",
                "Scroll Up": "اوپر سکرول کریں",
                "Scroll Down": "نیچے سکرول کریں",
                "Scroll Left": "بائیں سکرول کریں",
                "Scroll Right": "دائیں سکرول کریں",
                "Jump to Top": "اوپر جائیں",
                "Jump to Bottom": "نیچے جائیں",
                "Loading data from IndexedDB...": "IndexedDB سے ڈیٹا لوڈ ہو رہا ہے۔۔۔",
                "Error loading data from IndexedDB:": "IndexedDB سے ڈیٹا لوڈ کرنے میں خرابی:",
                "Data loaded. Rendering UI...": "ڈیٹا لوڈ ہو گیا۔ UI رینڈر کیا جا رہا ہے۔۔۔",
                "UI rendered.": "UI رینڈر ہو گیا۔",
                "Error rendering UI:": "UI رینڈر کرنے میں خرابی:",
                "Updating language...": "زبان اپ ڈیٹ کی جا رہی ہے۔۔۔",
                "Language updated.": "زبان اپ ڈیٹ ہو گئی۔",
                "Updating theme...": "تھیم اپ ڈیٹ کی جا رہی ہے۔۔۔",
                "Theme updated.": "تھیم اپ ڈیٹ ہو گئی۔",
                "Applying filters...": "فلٹرز لاگو کیے جا رہے ہیں۔۔۔",
                "Filters applied.": "فلٹرز لاگو ہو گئے۔",
                "Error applying filters:": "فلٹرز لاگو کرنے میں خرابی:",
                "Resetting filters...": "فلٹرز ری سیٹ کیے جا رہے ہیں۔۔۔",
                "Filters reset.": "فلٹرز ری سیٹ ہو گئے۔",
                "Navigating page...": "صفحہ نیویگیٹ کیا جا رہا ہے۔۔۔",
                "Page navigated.": "صفحہ نیویگیٹ ہو گیا۔",
                "Error navigating page:": "صفحہ نیویگیٹ کرنے میں خرابی:",
                "Displaying narrator details...": "راوی کی تفصیلات دکھائی جا رہی ہیں۔۔۔",
                "Details displayed.": "تفصیلات دکھا دی گئیں۔",
                "Error displaying details:": "تفصیلات دکھانے میں خرابی:",
                "Updating graph...": "گراف اپ ڈیٹ کیا جا رہا ہے۔۔۔",
                "Graph updated.": "گراف اپ ڈیٹ ہو گیا۔",
                "Error updating graph:": "گراف اپ ڈیٹ کرنے میں خرابی:",
                "Printing graph...": "گراف پرنٹ کیا جا رہا ہے۔۔۔",
                "Graph print initiated.": "گراف پرنٹ شروع ہو گیا۔",
                "Error initiating print:": "پرنٹ شروع کرنے میں خرابی:",
                "Searching narrator for path...": "راستے کے لیے راوی تلاش کیا جا رہا ہے۔۔۔",
                "Narrator found for path.": "راستے کے لیے راوی مل گیا۔",
                "Error searching narrator for path:": "راستے کے لیے راوی تلاش کرنے میں خرابی:",
                "Confirm Import": "امپورٹ کی تصدیق کریں",
                "Are you sure you want to import data? This will overwrite all existing narrators, bookmarks, and notes.": "کیا آپ واقعی ڈیٹا امپورٹ کرنا چاہتے ہیں؟ یہ تمام موجودہ راویوں، بک مارکس اور نوٹس کو اوور رائٹ کر دے گا۔",
                "Import Cancelled.": "امپورٹ منسوخ کر دیا گیا۔",
                "Confirm Reset": "ری سیٹ کی تصدیق کریں",
                "Are you sure you want to reset all filters?": "کیا آپ واقعی تمام فلٹرز ری سیٹ کرنا چاہتے ہیں؟",
                "Reset Cancelled.": "ری سیٹ منسوخ کر دیا گیا۔",
                "Confirm Delete Note": "نوٹ حذف کرنے کی تصدیق کریں",
                "Are you sure you want to delete the note for this narrator? This cannot be undone.": "کیا آپ واقعی اس راوی کا نوٹ حذف کرنا چاہتے ہیں؟ یہ عمل ناقابل واپسی ہے۔",
                "Delete Cancelled.": "حذف کرنا منسوخ کر دیا گیا۔",
                "Note deleted.": "نوٹ حذف کر دیا گیا۔",
                "Error deleting note:": "نوٹ حذف کرنے میں خرابی:",
                "Delete Note": "نوٹ حذف کریں",
                "No": "نہیں",
                "Yes": "ہاں",
                "Confirm Action": "عمل کی تصدیق کریں",
                "Operation cancelled.": "آپریشن منسوخ کر دیا گیا۔",
                "Processing...": "کارروائی جاری ہے۔۔۔",
                "Completed.": "مکمل ہو گیا۔",
                "Failed:": "ناکام:",
                "Success:": "کامیاب:",
                "Warning:": "انتباہ:",
                "Information:": "معلومات:",
                "Invalid Input": "غلط ان پٹ",
                "Value cannot be empty.": "ویلیو خالی نہیں ہو سکتی۔",
                "Invalid ID format.": "غلط ID فارمیٹ۔",
                "Item not found.": "آئٹم نہیں ملا۔",
                "Database error:": "ڈیٹا بیس خرابی:",
                "Network error:": "نیٹ ورک خرابی:",
                "File error:": "فائل خرابی:",
                "Parsing error:": "پارسنگ خرابی:",
                "Unknown error:": "نامعلوم خرابی:",
                "Please wait...": "براہ کرم انتظار کریں...",
                "Ready.": "تیار ہے۔",
                "Saving settings...": "ترتیبات محفوظ کی جا رہی ہیں۔۔۔",
                "Settings saved.": "ترتیبات محفوظ ہو گئیں۔",
                "Error saving settings:": "ترتیبات محفوظ کرنے میں خرابی:",
                "Loading settings...": "ترتیبات لوڈ ہو رہی ہیں۔۔۔",
                "Settings loaded.": "ترتیبات لوڈ ہو گئیں۔",
                "Error loading settings:": "ترتیبات لوڈ کرنے میں خرابی:",
                "Default settings applied.": "ڈیفالٹ ترتیبات لاگو ہو گئیں۔",
                "Confirm Reset Settings": "ترتیبات ری سیٹ کرنے کی تصدیق کریں",
                "Are you sure you want to reset all settings to their defaults?": "کیا آپ واقعی تمام ترتیبات کو ان کے ڈیفالٹ پر ری سیٹ کرنا چاہتے ہیں؟",
                "Settings reset cancelled.": "ترتیبات ری سیٹ منسوخ کر دیا گیا۔",
                "Settings reset to default.": "ترتیبات ڈیفالٹ پر ری سیٹ ہو گئیں۔",
                "Error resetting settings:": "ترتیبات ری سیٹ کرنے میں خرابی:",
                "Reset Settings": "ترتیبات ری سیٹ کریں",
                "Author: Yasin Ullah (Pakistani)": "مصنف: یاسین اللہ (پاکستانی)",
                "App Version: {version}": "ایپ ورژن: {version}",
                "Data Source: {source}": "ڈیٹا ماخذ: {source}",
                "Total Narrators: {count}": "کل راوی: {count}",
                "Bookmarked: {count}": "بک مارک شدہ: {count}",
                "Notes Added: {count}": "شامل کردہ نوٹس: {count}",
                "Last Updated: {date}": "آخری اپ ڈیٹ: {date}",
                "Database Status: {status}": "ڈیٹا بیس کی حیثیت: {status}",
                "Online": "آن لائن",
                "Offline": "آف لائن",
                "Connected": "منسلک",
                "Disconnected": "غیر منسلک",
                "Loading": "لوڈ ہو رہا ہے",
                "Idle": "فارغ",
                "Busy": "مصروف",
                "Error": "خرابی",
                "Not Initialized": "شروع نہیں ہوا",
                "Data Available": "ڈیٹا دستیاب ہے",
                "No Data": "کوئی ڈیٹا نہیں",
                "Requires Load": "لوڈ درکار ہے",
                "Data Loading": "ڈیٹا لوڈ ہو رہا ہے",
                "Data Ready": "ڈیٹا تیار ہے",
                "Exporting...": "ایکسپورٹ ہو رہا ہے۔۔۔",
                "Importing...": "امپورٹ ہو رہا ہے۔۔۔",
                "Clearing Data...": "ڈیٹا صاف کیا جا رہا ہے۔۔۔",
                "Verifying Data...": "ڈیٹا کی تصدیق کی جا رہی ہے۔۔۔",
                "Verification Complete.": "تصدیق مکمل۔",
                "Verification Failed.": "تصدیق ناکام۔",
                "Backup Recommended": "بیک اپ تجویز کیا جاتا ہے",
                "Consider exporting your data regularly as a backup.": "بیک اپ کے طور پر اپنے ڈیٹا کو باقاعدگی سے ایکسپورٹ کرنے پر غور کریں۔",
                "Backup & Restore": "بیک اپ اور بحالی",
                "Use Export/Import JSON buttons for backup and restore operations.": "بیک اپ اور بحالی کے آپریشنز کے لیے JSON ایکسپورٹ/امپورٹ بٹن استعمال کریں۔",
                "Data Integrity Check": "ڈیٹا انٹیگریٹی چیک",
                "Running data integrity check...": "ڈیٹا انٹیگریٹی چیک چل رہا ہے۔۔۔",
                "Integrity check passed.": "انٹیگریٹی چیک پاس ہو گیا۔",
                "Integrity check failed. Issues found: {issues}": "انٹیگریٹی چیک ناکام ہو گیا۔ مسائل پائے گئے: {issues}",
                "Attempting repair...": "مرمت کی کوشش کی جا رہی ہے۔۔۔",
                "Repair successful.": "مرمت کامیاب۔",
                "Repair failed. Manual intervention may be required.": "مرمت ناکام ہو گئی۔ دستی مداخلت کی ضرورت ہو سکتی ہے۔",
                "Check Console": "کنسول چیک کریں",
                "Check the browser console (F12) for detailed error messages.": "تفصیلی خرابی کے پیغامات کے لیے براؤزر کنسول (F12) چیک کریں۔",
                "Report Bug": "بگ رپورٹ کریں",
                "If you encounter persistent issues, please report the bug with details.": "اگر آپ کو مستقل مسائل کا سامنا کرنا پڑتا ہے، تو براہ کرم تفصیلات کے ساتھ بگ رپورٹ کریں۔",
                "System Information": "سسٹم کی معلومات",
                "Browser: {browser}": "براؤزر: {browser}",
                "OS: {os}": "آپریٹنگ سسٹم: {os}",
                "Screen Resolution: {resolution}": "سکرین ریزولوشن: {resolution}",
                "Memory Usage: {memory}": "میموری کا استعمال: {memory}",
                "Performance Metrics": "کارکردگی کے میٹرکس",
                "Load Time: {time} ms": "لوڈ ٹائم: {time} ملی سیکنڈ",
                "Query Time: {time} ms": "کوئری ٹائم: {time} ملی سیکنڈ",
                "Render Time: {time} ms": "رینڈر ٹائم: {time} ملی سیکنڈ",
                "Graph Render Time: {time} ms": "گراف رینڈر ٹائم: {time} ملی سیکنڈ",
                "Pathfind Time: {time} ms": "راستہ تلاش کرنے کا وقت: {time} ملی سیکنڈ",
                "Memory Peak: {memory} MB": "میموری کی چوٹی: {memory} MB",
                "Optimization Tips": "اصلاح کی تجاویز",
                "Use filters to narrow down results for faster loading.": "تیز لوڈنگ کے لیے نتائج کو محدود کرنے کے لیے فلٹرز استعمال کریں۔",
                "Keep the number of simultaneously displayed graph nodes manageable.": "بیک وقت دکھائے جانے والے گراف نوڈز کی تعداد کو قابل انتظام رکھیں۔",
                "Ensure sufficient disk space for IndexedDB storage.": "IndexedDB اسٹوریج کے لیے کافی ڈسک کی جگہ یقینی بنائیں۔",
                "Clear browser cache if experiencing persistent slowness.": "اگر مستقل سستی کا سامنا ہو تو براؤزر کیش صاف کریں۔",
                "Consider using a modern browser for best performance.": "بہترین کارکردگی کے لیے جدید براؤزر استعمال کرنے پر غور کریں۔",
                "Accessibility Features": "رسائی کی خصوصیات",
                "Keyboard Navigation: Use Tab/Shift+Tab, Enter/Space, Arrow Keys.": "کی بورڈ نیویگیشن: Tab/Shift+Tab، Enter/Space، تیر والے بٹن استعمال کریں۔",
                "Screen Reader Support: Basic ARIA roles and labels implemented.": "سکرین ریڈر سپورٹ: بنیادی ARIA رولز اور لیبلز لاگو کیے گئے ہیں۔",
                "High Contrast Mode: Follows system/browser high contrast settings where possible.": "ہائی کنٹراسٹ موڈ: جہاں ممکن ہو سسٹم/براؤزر ہائی کنٹراسٹ سیٹنگز کی پیروی کرتا ہے۔",
                "Text Resizing: UI should adapt to browser text size adjustments.": "ٹیکسٹ ریسائزنگ: UI کو براؤزر ٹیکسٹ سائز ایڈجسٹمنٹ کے مطابق ڈھالنا چاہیے۔",
                "Feedback Welcome": "رائے خوش آئند ہے",
                "Your feedback is valuable for improving this tool.": "آپ کی رائے اس ٹول کو بہتر بنانے کے لیے قیمتی ہے۔",
                "Contact": "رابطہ",
                "For support or feedback, contact the author.": "سپورٹ یا رائے کے لیے، مصنف سے رابطہ کریں۔",
                "License Information": "لائسنس کی معلومات",
                "This software is provided 'as-is' without warranty. Use at your own risk.": "یہ سافٹ ویئر 'جیسا ہے' بغیر کسی وارنٹی کے فراہم کیا گیا ہے۔ اپنے خطرے پر استعمال کریں۔",
                "Source Code": "سورس کوڈ",
                "Source code might be available upon request or repository link.": "سورس کوڈ درخواست پر یا ریپوزٹری لنک کے ذریعے دستیاب ہو سکتا ہے۔",
                "Acknowledgements": "اعترافات",
                "Data sourced from [Specify Source if known].": "ڈیٹا [اگر معلوم ہو تو ماخذ بتائیں] سے حاصل کیا گیا ہے۔",
                "Built with Vanilla JS and IndexedDB.": "ونیلا JS اور IndexedDB کے ساتھ بنایا گیا ہے۔",
                "Special thanks to the Islamic scholarship community.": "اسلامی اسکالرشپ کمیونٹی کا خصوصی شکریہ۔",
                "Privacy Policy": "رازداری کی پالیسی",
                "All data is stored locally in your browser's IndexedDB. No data is sent to any server.": "تمام ڈیٹا مقامی طور پر آپ کے براؤزر کے IndexedDB میں محفوظ کیا جاتا ہے۔ کوئی ڈیٹا کسی سرور پر نہیں بھیجا جاتا۔",
                "Clearing browser data will remove all stored information.": "براؤزر ڈیٹا صاف کرنے سے تمام ذخیرہ شدہ معلومات ہٹ جائیں گی۔",
                "Use the Export feature to create backups.": "بیک اپ بنانے کے لیے ایکسپورٹ فیچر استعمال کریں۔",
                "Terms of Service": "سروس کی شرائط",
                "Refer to License Information.": "لائسنس کی معلومات دیکھیں۔",
                "User Guide": "صارف گائیڈ",
                "Loading Data: Data from '{csv}' is loaded into the browser database on first run.": "ڈیٹا لوڈنگ: '{csv}' سے ڈیٹا پہلی بار چلانے پر براؤزر ڈیٹا بیس میں لوڈ ہوتا ہے۔",
                "Searching/Filtering: Use the controls above the list to find specific narrators.": "تلاش/فلٹرنگ: مخصوص راویوں کو تلاش کرنے کے لیے فہرست کے اوپر کنٹرولز استعمال کریں۔",
                "Viewing Details: Click a narrator in the list or graph to see their details.": "تفصیلات دیکھنا: فہرست یا گراف میں کسی راوی پر کلک کرکے ان کی تفصیلات دیکھیں۔",
                "Navigation: Clickable links (IDs) in details navigate to related narrators.": "نیویگیشن: تفصیلات میں قابل کلک لنکس (IDs) متعلقہ راویوں تک لے جاتے ہیں۔",
                "Graph: Shows relationships (Teachers/Students). Use mouse wheel to zoom, click-and-drag to pan.": "گراف: تعلقات (اساتذہ/تلامذہ) دکھاتا ہے۔ زوم کرنے کے لیے ماؤس وہیل استعمال کریں، پین کرنے کے لیے کلک کرکے گھسیٹیں۔",
                "Bookmarks/Notes: Save narrators or add personal notes in the details panel.": "بک مارکس/نوٹس: تفصیلات پینل میں راویوں کو محفوظ کریں یا ذاتی نوٹس شامل کریں۔",
                "Path Tracing: Find connection paths between two narrators using the tracer tool.": "راستہ ٹریسنگ: ٹریسر ٹول کا استعمال کرتے ہوئے دو راویوں کے درمیان کنکشن کے راستے تلاش کریں۔",
                "Export/Import: Backup your data (including notes/bookmarks) or restore from a backup using the JSON buttons in the header.": "ایکسپورٹ/امپورٹ: ہیڈر میں JSON بٹنوں کا استعمال کرتے ہوئے اپنے ڈیٹا (بشمول نوٹس/بک مارکس) کا بیک اپ لیں یا بیک اپ سے بحال کریں۔",
                "Language/Theme: Toggle between English/Urdu and Light/Dark modes using header buttons.": "زبان/تھیم: ہیڈر بٹنوں کا استعمال کرتے ہوئے انگریزی/اردو اور لائٹ/ڈارک موڈز کے درمیان ٹوگل کریں۔",
                "Printing: Use the 'Print Graph' button to print the current visualization.": "پرنٹنگ: موجودہ ویژولائزیشن کو پرنٹ کرنے کے لیے 'گراف پرنٹ کریں' بٹن استعمال کریں۔",
                "Troubleshooting": "مسائل کا حل",
                "If data doesn't load, ensure '{csv}' is in the same directory and check browser console (F12) for errors.": "اگر ڈیٹا لوڈ نہیں ہوتا ہے، تو یقینی بنائیں کہ '{csv}' اسی ڈائرکٹری میں ہے اور خرابیوں کے لیے براؤزر کنسول (F12) چیک کریں۔",
                "If the app is slow, try resetting filters or restarting the browser.": "اگر ایپ سست ہے، تو فلٹرز ری سیٹ کرنے یا براؤزر کو دوبارہ شروع کرنے کی کوشش کریں۔",
                "Import errors usually mean the JSON file is invalid or corrupted.": "امپورٹ کی خرابیاں عام طور پر اس بات کی نشاندہی کرتی ہیں کہ JSON فائل غلط یا خراب ہے۔",
                "Ensure you have enough disk space for IndexedDB.": "یقینی بنائیں کہ آپ کے پاس IndexedDB کے لیے کافی ڈسک کی جگہ ہے۔",
                "Contact author for persistent issues.": "مستقل مسائل کے لیے مصنف سے رابطہ کریں۔",
                "Feature Roadmap (Potential Future Ideas)": "فیچر روڈ میپ (ممکنہ مستقبل کے خیالات)",
                "Advanced Graph Layouts": "جدید گراف لے آؤٹ",
                "Timeline Visualization": "ٹائم لائن ویژولائزیشن",
                "Geographical Mapping": "جغرافیائی نقشہ سازی",
                "Statistical Analysis": "شماریاتی تجزیہ",
                "User Accounts (Server-based - NOT CURRENTLY PLANNED)": "صارف اکاؤنٹس (سرور پر مبنی - فی الحال منصوبہ بندی نہیں)",
                "Collaborative Features (Server-based - NOT CURRENTLY PLANNED)": "تعاونی خصوصیات (سرور پر مبنی - فی الحال منصوبہ بندی نہیں)",
                "More Data Sources Integration": "مزید ڈیٹا ذرائع کا انضمام",
                "Enhanced Search Capabilities (e.g., fuzzy search, boolean logic)": "بہتر تلاش کی صلاحیتیں (مثلاً، فزی سرچ، بولین منطق)",
                "Customizable UI Themes": "مرضی کے مطابق UI تھیمز",
                "Offline Mode Improvements (Service Worker - currently excluded)": "آف لائن موڈ میں بہتری (سروس ورکر - فی الحال خارج)",
                "Mobile App Version (Native)": "موبائل ایپ ورژن (نیٹیو)",
                "API for External Tools": "بیرونی ٹولز کے لیے API",
                "Integration with Hadith Databases": "حدیث ڈیٹا بیس کے ساتھ انضمام",
                "Automated Data Validation/Cleaning Tools": "خودکار ڈیٹا کی توثیق/صفائی کے اوزار",
                "Version History / Changelog": "ورژن ہسٹری / چینج لاگ",
                "Initial Release (v1.0): Core features implemented.": "ابتدائی ریلیز (v1.0): بنیادی خصوصیات لاگو کی گئیں۔",
                "Known Issues": "معلوم مسائل",
                "Graph performance may degrade with very large numbers of nodes displayed simultaneously.": "بیک وقت بہت زیادہ تعداد میں نوڈز دکھائے جانے پر گراف کی کارکردگی کم ہو سکتی ہے۔",
                "Complex CSV parsing (nested quotes/escapes) might have edge cases.": "پیچیدہ CSV پارسنگ (نیسٹڈ کوٹس/ایسکیپس) میں ایج کیسز ہو سکتے ہیں۔",
                "RTL text rendering in SVG might vary slightly across browsers.": "SVG میں RTL ٹیکسٹ رینڈرنگ براؤزرز میں تھوڑا مختلف ہو سکتا ہے۔",
                "Pathfinding for very distant narrators can be slow.": "بہت دور کے راویوں کے لیے راستہ تلاش کرنا سست ہو سکتا ہے۔",
                "Print styling might need adjustments based on browser.": "پرنٹ اسٹائلنگ کو براؤزر کی بنیاد پر ایڈجسٹمنٹ کی ضرورت ہو سکتی ہے۔",
                "Memory usage can be high during initial data load or large exports.": "ابتدائی ڈیٹا لوڈ یا بڑے ایکسپورٹ کے دوران میموری کا استعمال زیادہ ہو سکتا ہے۔",
                "No Service Worker for offline caching (as per requirement).": "آف لائن کیشنگ کے لیے کوئی سروس ورکر نہیں (ضرورت کے مطابق)۔",
                "Dependencies: None (except web fonts if used by browser/OS).": "انحصار: کوئی نہیں (سوائے ویب فونٹس کے اگر براؤزر/OS استعمال کرے)۔",
                "Compatibility: Modern browsers (Chrome, Firefox, Edge, Safari) supporting IndexedDB, ES6+.": "مطابقت: جدید براؤزر (کروم، فائر فاکس، ایج، سفاری) جو IndexedDB، ES6+ کو سپورٹ کرتے ہیں۔",
                "Data Accuracy Disclaimer": "ڈیٹا کی درستگی کا اعلان",
                "The accuracy of the narrator data depends entirely on the source CSV file.": "راوی ڈیٹا کی درستگی مکمل طور پر ماخذ CSV فائل پر منحصر ہے۔",
                "This tool is for exploration and visualization; verify critical information with primary sources.": "یہ ٹول تحقیق اور ویژولائزیشن کے لیے ہے؛ اہم معلومات کی تصدیق بنیادی ذرائع سے کریں۔",
                "Report any data inaccuracies to the source provider if possible.": "اگر ممکن ہو تو کسی بھی ڈیٹا کی غلطیوں کی اطلاع ماخذ فراہم کنندہ کو دیں۔",
                "The author of this tool is not responsible for data errors in the source file.": "اس ٹول کا مصنف ماخذ فائل میں ڈیٹا کی غلطیوں کا ذمہ دار نہیں ہے۔",
                "Final Note": "آخری نوٹ",
                "This application aims to be a helpful tool for researchers and students of Isnad.": "اس ایپلیکیشن کا مقصد اسناد کے محققین اور طلباء کے لیے ایک مددگار ٹول بننا ہے۔",
                "Developed with care by Yasin Ullah.": "یاسین اللہ نے احتیاط سے تیار کیا ہے۔",
                "Feedback and contributions (if applicable) are welcome.": "رائے اور شراکتیں (اگر قابل اطلاق ہوں) خوش آئند ہیں۔",
                "May this tool benefit your studies.": "اللہ کرے یہ ٹول آپ کے مطالعہ میں فائدہ مند ثابت ہو۔",
                "Allah knows best.": "اللہ بہتر جانتا ہے۔",
            }
        };

        // --- Utility Functions ---
        function translate(key, lang = currentLanguage, params = {}) {
            const langDict = translations[lang] || translations.en;
            let text = langDict[key] || translations.en[key] || key; // Fallback chain: current lang -> english -> key itself
            for (const param in params) {
                text = text.replace(`{${param}}`, params[param]);
            }
            return text;
        }

        function updateUIStrings() {
            document.querySelectorAll('[data-translate-en]').forEach(el => {
                const keyEn = el.getAttribute('data-translate-en');
                const keyUr = el.getAttribute('data-translate-ur');
                const key = (currentLanguage === 'ur' && keyUr) ? keyUr : keyEn; // Prefer Urdu key if lang is Urdu and key exists
                const translationKey = keyEn; // Use English key for lookup in translations object

                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    if (el.hasAttribute('placeholder')) {
                        const placeholderKeyEn = el.getAttribute('data-translate-placeholder-en');
                        const placeholderKeyUr = el.getAttribute('data-translate-placeholder-ur');
                        const placeholderKey = (currentLanguage === 'ur' && placeholderKeyUr) ? placeholderKeyUr : placeholderKeyEn;
                        el.placeholder = translate(placeholderKeyEn, currentLanguage); // Translate using EN key
                    } else {
                         // Handle input value if needed, though less common for static translation attributes
                         // el.value = translate(translationKey, currentLanguage);
                    }
                } else if (el.tagName === 'OPTION') {
                     // Handle option text specifically if needed, often covered by general case
                     el.textContent = translate(translationKey, currentLanguage);
                }
                 else {
                    el.textContent = translate(translationKey, currentLanguage);
                }
            });

            // Update dynamic elements like pagination, titles etc.
             pageInfoEl.textContent = translate("Page {current} of {total}", currentLanguage, { current: currentPage, total: totalPages });
             document.title = translate("Isnad Narrators Explorer", currentLanguage);

             // Update button text based on state if necessary (e.g., bookmark button)
             updateBookmarkButtonText(selectedNarratorId); // Re-translate bookmark button
             updateBookmarksFilterButtonText(); // Re-translate filter button

             // Update details placeholder
             if (!selectedNarratorId) {
                 detailsContentEl.textContent = translate("Select a narrator from the list.", currentLanguage);
             }
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('language', lang);
            document.documentElement.lang = lang;
            document.documentElement.dir = lang === 'ur' ? 'rtl' : 'ltr';
            langToggleBtn.textContent = lang === 'ur' ? translate('English', 'ur') : translate('اردو', 'en'); // Set button text to opposite language
            updateUIStrings();
            // Re-render list/details if language affects content significantly (e.g., names)
            if (selectedNarratorId) displayNarratorDetails(selectedNarratorId);
            renderNarratorList(currentNarratorList); // Re-render list to apply potential RTL styling/text changes
            // Re-render graph text if needed (might require more complex update logic)
            if (selectedNarratorId) updateGraphVisualization(selectedNarratorId);
        }

        function setTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('theme', theme);
            document.body.classList.toggle('dark-theme', theme === 'dark');
            themeToggleBtn.textContent = theme === 'dark' ? translate('Light Mode', currentLanguage) : translate('Dark Mode', currentLanguage);
            // Update graph colors if needed (handled by CSS variables)
            if (selectedNarratorId) updateGraphVisualization(selectedNarratorId); // Re-render to apply new theme colors via CSS vars
        }

        function showLoading(messageKey, progressValue = null) {
            loadingMessage.textContent = translate(messageKey, currentLanguage);
            if (progressValue !== null) {
                loadingProgress.value = progressValue;
                loadingProgress.style.display = 'block';
            } else {
                loadingProgress.style.display = 'none'; // Hide progress bar if no value
            }
            loadingOverlay.classList.remove('hidden');
        }

        function hideLoading() {
            loadingOverlay.classList.add('hidden');
        }

        function showStatusMessage(messageKey, type = 'info', params = {}, duration = 5000) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `status-message ${type}`;
            messageDiv.textContent = translate(messageKey, currentLanguage, params);
            statusArea.innerHTML = ''; // Clear previous messages
            statusArea.appendChild(messageDiv);

            if (duration > 0) {
                setTimeout(() => {
                    if (messageDiv.parentNode === statusArea) { // Check if it hasn't been replaced
                       statusArea.removeChild(messageDiv);
                    }
                }, duration);
            }
        }

        function clearStatusMessage() {
             statusArea.innerHTML = '';
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- IndexedDB Functions ---
        function openDB() {
            return new Promise((resolve, reject) => {
                if (!('indexedDB' in window)) {
                     reject(new Error(translate("IndexedDB not supported by this browser.")));
                     return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB upgrade needed");

                    // Narrators Store
                    if (!db.objectStoreNames.contains(NARRATORS_STORE)) {
                        const narratorStore = db.createObjectStore(NARRATORS_STORE, { keyPath: 'scholar_indx' });
                        narratorStore.createIndex('name_lower', 'name_lower', { unique: false }); // For case-insensitive search
                        narratorStore.createIndex('grade', 'grade', { unique: false });
                        narratorStore.createIndex('tags', 'tags', { unique: false, multiEntry: true }); // Index each tag
                        narratorStore.createIndex('categories', 'categories', { unique: false, multiEntry: true }); // Index each category
                        // Add more indexes as needed for filtering performance
                        console.log(`Object store '${NARRATORS_STORE}' created.`);
                    } else {
                         // Handle potential index updates in future versions if needed
                         const transaction = event.target.transaction;
                         const narratorStore = transaction.objectStore(NARRATORS_STORE);
                         if (!narratorStore.indexNames.contains('categories')) {
                             narratorStore.createIndex('categories', 'categories', { unique: false, multiEntry: true });
                             console.log("Added 'categories' index.");
                         }
                          if (!narratorStore.indexNames.contains('name_lower')) {
                             narratorStore.createIndex('name_lower', 'name_lower', { unique: false });
                             console.log("Added 'name_lower' index.");
                         }
                         // Add checks for other indexes if necessary
                    }


                    // Bookmarks Store
                    if (!db.objectStoreNames.contains(BOOKMARKS_STORE)) {
                        db.createObjectStore(BOOKMARKS_STORE, { keyPath: 'scholar_indx' });
                        console.log(`Object store '${BOOKMARKS_STORE}' created.`);
                    }

                    // Notes Store
                    if (!db.objectStoreNames.contains(NOTES_STORE)) {
                        db.createObjectStore(NOTES_STORE, { keyPath: 'scholar_indx' });
                         console.log(`Object store '${NOTES_STORE}' created.`);
                    }

                    // Metadata Store
                    if (!db.objectStoreNames.contains(METADATA_STORE)) {
                        db.createObjectStore(METADATA_STORE, { keyPath: 'key' });
                         console.log(`Object store '${METADATA_STORE}' created.`);
                    }
                     console.log("IndexedDB upgrade complete.");
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Database opened successfully.");
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error("Database error:", event.target.error);
                    reject(new Error(translate("Error initializing database:") + ` ${event.target.error}`));
                };
            });
        }

        function getMetadata(key) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(METADATA_STORE, 'readonly');
                const store = transaction.objectStore(METADATA_STORE);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result ? request.result.value : undefined);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function setMetadata(key, value) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(METADATA_STORE, 'readwrite');
                const store = transaction.objectStore(METADATA_STORE);
                const request = store.put({ key: key, value: value });
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function clearStore(storeName) {
             return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
                transaction.oncomplete = () => resolve(); // Ensure transaction completes
                transaction.onerror = (event) => reject(event.target.error);
            });
        }

        function bulkAdd(storeName, items) {
            return new Promise((resolve, reject) => {
                if (!db || !items || items.length === 0) return resolve(); // Nothing to add or DB not ready
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                let count = 0;

                items.forEach(item => {
                    const request = store.put(item); // Use put to allow overwriting during import
                    request.onsuccess = () => {
                        count++;
                        if (count === items.length) {
                            // All puts initiated, wait for transaction to complete
                        }
                    };
                    request.onerror = (event) => {
                        console.error(`Error adding item to ${storeName}:`, item, event.target.error);
                        // Don't reject immediately, let transaction try to finish others
                    };
                });

                transaction.oncomplete = () => {
                    console.log(`Bulk add to ${storeName} complete. Added/Updated ${count} items.`);
                    resolve();
                };
                transaction.onerror = (event) => {
                    console.error(`Transaction error during bulk add to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getNarratorById(id) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(NARRATORS_STORE, 'readonly');
                const store = transaction.objectStore(NARRATORS_STORE);
                const request = store.get(id); // ID is the keyPath

                request.onsuccess = () => {
                    resolve(request.result);
                };
                request.onerror = (event) => {
                    console.error(`Error fetching narrator ${id}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getAllRecords(storeName) {
             return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function getNote(scholar_indx) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(NOTES_STORE, 'readonly');
                const store = transaction.objectStore(NOTES_STORE);
                const request = store.get(scholar_indx);
                request.onsuccess = () => resolve(request.result ? request.result.text : '');
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function saveNote(scholar_indx, text) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(NOTES_STORE, 'readwrite');
                const store = transaction.objectStore(NOTES_STORE);
                const request = store.put({ scholar_indx: scholar_indx, text: text });
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

         function deleteNote(scholar_indx) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(NOTES_STORE, 'readwrite');
                const store = transaction.objectStore(NOTES_STORE);
                const request = store.delete(scholar_indx);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function isBookmarked(scholar_indx) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(BOOKMARKS_STORE, 'readonly');
                const store = transaction.objectStore(BOOKMARKS_STORE);
                const request = store.get(scholar_indx);
                request.onsuccess = () => resolve(!!request.result); // True if record exists
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function toggleBookmark(scholar_indx) {
            return new Promise(async (resolve, reject) => {
                if (!db) return reject("DB not open");
                const currentlyBookmarked = await isBookmarked(scholar_indx).catch(reject);
                if (currentlyBookmarked === undefined) return; // Error occurred in isBookmarked

                const transaction = db.transaction(BOOKMARKS_STORE, 'readwrite');
                const store = transaction.objectStore(BOOKMARKS_STORE);
                let request;

                if (currentlyBookmarked) {
                    request = store.delete(scholar_indx);
                } else {
                    request = store.put({ scholar_indx: scholar_indx });
                }

                request.onsuccess = () => resolve(!currentlyBookmarked); // Return the new state
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function getBookmarkedIds() {
             return new Promise((resolve, reject) => {
                if (!db) return reject("DB not open");
                const transaction = db.transaction(BOOKMARKS_STORE, 'readonly');
                const store = transaction.objectStore(BOOKMARKS_STORE);
                const request = store.getAllKeys(); // More efficient than getAll
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }


        // --- CSV Parsing ---
        // Basic CSV parser, handles simple quotes, might need enhancement for complex cases
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return { headers: [], data: [] }; // Need header + data

            // Robust header extraction (handles potential BOM and CR)
            const headerLine = lines[0].trim().replace(/^\uFEFF/, ''); // Remove BOM
            const headers = headerLine.split(',').map(h => h.trim());

            const data = [];
            const headerCount = headers.length;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines

                const values = [];
                let currentVal = '';
                let inQuotes = false;

                for (let j = 0; j < line.length; j++) {
                    const char = line[j];

                    if (char === '"') {
                        // Handle double quotes inside quoted field ("") -> "
                        if (inQuotes && line[j + 1] === '"') {
                            currentVal += '"';
                            j++; // Skip the next quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentVal.trim());
                        currentVal = '';
                    } else {
                        currentVal += char;
                    }
                }
                values.push(currentVal.trim()); // Add the last value

                // Basic validation/correction: if row has wrong number of columns, pad/truncate
                if (values.length !== headerCount) {
                     console.warn(`CSV Parse Warning: Row ${i + 1} has ${values.length} columns, expected ${headerCount}. Line: "${line}"`);
                     // Pad with empty strings or truncate
                     if (values.length < headerCount) {
                         while (values.length < headerCount) values.push('');
                     } else {
                         values.length = headerCount;
                     }
                }


                const rowObject = {};
                headers.forEach((header, index) => {
                    let value = values[index] || ''; // Default to empty string if undefined

                    // Attempt to parse specific fields
                    if (header === 'scholar_indx' || header.endsWith('_hijri') || header.endsWith('_gregorian')) {
                        const num = parseInt(value, 10);
                        rowObject[header] = isNaN(num) ? null : num; // Store as number or null
                    } else if (header === 'teachers_inds' || header === 'students_inds') {
                        // Split comma-separated IDs, trim, filter empty, convert to numbers
                        rowObject[header] = value.split(',')
                                                .map(id => id.trim())
                                                .filter(id => id !== '' && !isNaN(parseInt(id, 10)))
                                                .map(id => parseInt(id, 10));
                    } else if (header === 'tags') {
                         // Split tags like "Tag1 [Tag1] , Tag2 [Tag2]"
                         rowObject[header] = value.split(',')
                                                .map(tag => tag.trim().split('[')[0].trim()) // Get text before '['
                                                .filter(tag => tag !== '');
                    } else if (header === 'area_of_interest') {
                         // Split categories like "Tafsir/Quran, Recitation/Quran"
                         rowObject[header] = value.split(',')
                                                .map(cat => cat.trim().split('/')[0].trim()) // Get main category before '/'
                                                .filter(cat => cat !== '');
                    }
                    else {
                        rowObject[header] = value; // Keep as string
                    }
                });

                 // Add derived fields
                 rowObject['name_lower'] = (rowObject['name'] || '').toLowerCase();
                 rowObject['categories'] = rowObject['area_of_interest'] || []; // Use parsed categories

                // Ensure essential fields exist
                if (rowObject.scholar_indx === null || rowObject.scholar_indx === undefined) {
                     console.warn(`CSV Parse Warning: Row ${i + 1} skipped due to missing or invalid 'scholar_indx'. Line: "${line}"`);
                     continue; // Skip rows without a valid ID
                }

                data.push(rowObject);
            }

            return { headers, data };
        }


        // --- Data Loading and Initialization ---
        async function loadDataFromCSV() {
            try {
                showLoading("Fetching CSV file...", 0);
                const response = await fetch(CSV_FILE_PATH);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const fileSize = response.headers.get('content-length');
                showLoading(translate("CSV file fetched. Size: {size} bytes", currentLanguage, {size: fileSize || 'Unknown'}), 10);

                const csvText = await response.text();
                showLoading("Parsing CSV...", 30);
                console.log("Parsing CSV...");
                const { headers, data } = parseCSV(csvText);
                 if (!data || data.length === 0) {
                     throw new Error("CSV parsing resulted in no data.");
                 }
                console.log(`CSV parsed. ${data.length} records found.`);
                showLoading(translate("CSV parsed. {count} records found.", currentLanguage, {count: data.length}), 50);

                // Populate unique values for filters before storing
                showLoading("Populating unique filters...", 60);
                uniqueGrades.clear();
                uniqueTags.clear();
                uniqueCategories.clear();
                data.forEach(narrator => {
                    if (narrator.grade) uniqueGrades.add(narrator.grade);
                    if (narrator.tags && Array.isArray(narrator.tags)) {
                        narrator.tags.forEach(tag => { if (tag) uniqueTags.add(tag); });
                    }
                     if (narrator.categories && Array.isArray(narrator.categories)) {
                        narrator.categories.forEach(cat => { if (cat) uniqueCategories.add(cat); });
                    }
                });
                console.log("Unique filters populated.");
                 showLoading("Unique filters populated.", 70);

                // Store data in IndexedDB
                showLoading(translate("Storing data in database...", currentLanguage), 80);
                console.log("Storing data in IndexedDB...");
                await clearStore(NARRATORS_STORE); // Clear before adding new data
                await bulkAdd(NARRATORS_STORE, data);

                // Store metadata (load status, unique values)
                await setMetadata('dataLoaded', true);
                await setMetadata('totalNarrators', data.length);
                await setMetadata('uniqueGrades', Array.from(uniqueGrades).sort());
                await setMetadata('uniqueTags', Array.from(uniqueTags).sort());
                await setMetadata('uniqueCategories', Array.from(uniqueCategories).sort());
                await setMetadata('lastUpdated', new Date().toISOString());

                console.log("Data stored successfully.");
                showLoading("Data loaded successfully.", 100);
                showStatusMessage("Data loaded successfully.", 'success');
                return true;

            } catch (error) {
                console.error("Error loading data from CSV:", error);
                showStatusMessage(translate("Error loading or processing CSV:") + ` ${error.message}`, 'error', {}, 0); // Keep error message visible
                hideLoading(); // Hide progress on error
                await setMetadata('dataLoaded', false); // Mark as not loaded on error
                return false;
            }
        }

        async function initializeApp() {
            showLoading("Initializing application...");
            try {
                // 1. Apply initial theme and language
                setTheme(currentTheme);
                setLanguage(currentLanguage); // This also calls updateUIStrings

                // 2. Open IndexedDB
                showLoading("Initializing database connection...");
                db = await openDB();
                showLoading("Database connection successful.");

                // 3. Check if data is loaded
                showLoading("Checking data status...");
                const dataLoaded = await getMetadata('dataLoaded');
                const totalNarrators = await getMetadata('totalNarrators');
                console.log("Data loaded status:", dataLoaded, "Total narrators:", totalNarrators);
                showLoading("Data status checked.");

                if (dataLoaded && totalNarrators > 0) {
                    console.log("Database already populated.");
                    showLoading("Database already populated.");
                    // Load unique values from metadata
                    uniqueGrades = new Set(await getMetadata('uniqueGrades') || []);
                    uniqueTags = new Set(await getMetadata('uniqueTags') || []);
                    uniqueCategories = new Set(await getMetadata('uniqueCategories') || []);
                    populateFilterOptions();
                    showLoading("Loading narrator list...");
                    await loadAndDisplayNarrators();
                    showStatusMessage("Application Ready.", 'info');
                } else {
                    console.log("Data needs to be loaded from CSV.");
                    showLoading("Data needs to be loaded from CSV.");
                    showStatusMessage("Starting data load process...", 'info', {}, 0); // Persistent message
                    const success = await loadDataFromCSV();
                    if (success) {
                        populateFilterOptions();
                        showLoading("Loading narrator list...");
                        await loadAndDisplayNarrators();
                        showStatusMessage("Application Ready.", 'success');
                    } else {
                         // Error message already shown by loadDataFromCSV
                         showStatusMessage("Failed to load initial data. Please check console (F12) and ensure 'all_rawis.csv' is present.", 'error', {}, 0);
                    }
                }
            } catch (error) {
                console.error("Initialization failed:", error);
                showStatusMessage(translate("Error during initial data load:") + ` ${error.message}`, 'error', {}, 0);
            } finally {
                hideLoading();
            }
        }

        // --- UI Rendering and Interaction ---

        function populateFilterOptions() {
             try {
                showLoading("Populating filter options...");
                // Grades
                gradeFilter.innerHTML = `<option value="" data-translate-en="Filter by Grade..." data-translate-ur="درجہ کے لحاظ سے فلٹر کریں...">${translate("Filter by Grade...")}</option>`;
                Array.from(uniqueGrades).sort().forEach(grade => {
                    const option = document.createElement('option');
                    option.value = grade;
                    option.textContent = grade;
                    gradeFilter.appendChild(option);
                });

                // Tags
                tagFilter.innerHTML = `<option value="" data-translate-en="Filter by Tag..." data-translate-ur="ٹیگ کے لحاظ سے فلٹر کریں...">${translate("Filter by Tag...")}</option>`;
                Array.from(uniqueTags).sort().forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag;
                    option.textContent = tag;
                    tagFilter.appendChild(option);
                });

                 // Categories
                categoryFilter.innerHTML = `<option value="" data-translate-en="Filter by Category..." data-translate-ur="زمرہ کے لحاظ سے فلٹر کریں...">${translate("Filter by Category...")}</option>`;
                Array.from(uniqueCategories).sort().forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    categoryFilter.appendChild(option);
                });

                updateUIStrings(); // Re-apply translations to the new options
                console.log("Filter options populated.");
                showLoading("Filter options populated.");
            } catch (error) {
                 console.error("Error populating filters:", error);
                 showStatusMessage(translate("Error populating filters:") + ` ${error.message}`, 'error');
            }
        }

        function renderNarratorList(narratorIds) {
            narratorListEl.innerHTML = ''; // Clear previous list
            if (!narratorIds || narratorIds.length === 0) {
                narratorListEl.innerHTML = `<li>${translate("No narrators found matching your criteria.")}</li>`;
                return;
            }

            const fragment = document.createDocumentFragment();
            const promises = narratorIds.map(id => getNarratorById(id)); // Fetch details for display

            Promise.all(promises).then(narrators => {
                narrators.forEach(narrator => {
                    if (!narrator) return; // Skip if narrator not found (shouldn't happen ideally)
                    const li = document.createElement('li');
                    li.className = 'narrator-item';
                    li.dataset.id = narrator.scholar_indx;
                    li.innerHTML = `
                        <strong>${narrator.name || translate('Unknown')}</strong>
                        <br>
                        <small>${translate('Grade')}: ${narrator.grade || translate('N/A')}</small>
                    `;
                    if (narrator.scholar_indx === selectedNarratorId) {
                        li.classList.add('selected');
                    }
                    li.addEventListener('click', () => handleNarratorClick(narrator.scholar_indx));
                    fragment.appendChild(li);
                });
                narratorListEl.appendChild(fragment);
            }).catch(error => {
                 console.error("Error rendering narrator list items:", error);
                 narratorListEl.innerHTML = `<li>${translate("Error loading narrator list:")} ${error.message}</li>`;
            });
        }

        function updatePaginationControls(totalItems) {
            totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
            if (totalPages <= 0) totalPages = 1; // Ensure at least 1 page
            if (currentPage > totalPages) currentPage = totalPages; // Adjust if current page is out of bounds
            if (currentPage < 1) currentPage = 1;

            pageInfoEl.textContent = translate("Page {current} of {total}", currentLanguage, { current: currentPage, total: totalPages });
            prevPageBtn.disabled = currentPage <= 1;
            nextPageBtn.disabled = currentPage >= totalPages;

            paginationControlsEl.style.display = totalItems > 0 ? 'flex' : 'none';
        }

        async function loadAndDisplayNarrators(page = 1) {
            showLoading("Loading narrator list...");
            clearStatusMessage();
            currentPage = page;
            selectedNarratorId = null; // Deselect narrator when list changes
            clearDetailsPanel();
            clearGraph();
            actionsSection.classList.add('hidden');


            try {
                if (!db) throw new Error("Database not available.");

                const transaction = db.transaction(NARRATORS_STORE, 'readonly');
                const store = transaction.objectStore(NARRATORS_STORE);
                let index;
                let range = null;
                let direction = 'next'; // Default sort order (by primary key - ID)

                // --- Filtering Logic ---
                const filters = [];
                const lowerSearchTerm = currentFilters.search.toLowerCase();

                // 1. Bookmarks Filter (Primary if active)
                if (currentFilters.bookmarkedOnly) {
                    const bookmarkedIds = await getBookmarkedIds();
                    if (bookmarkedIds.length === 0) {
                         currentNarratorList = [];
                         updatePaginationControls(0);
                         renderNarratorList([]);
                         hideLoading();
                         return; // No bookmarks, nothing to show
                    }
                    // Create a filter function for bookmarks
                    filters.push(narrator => bookmarkedIds.includes(narrator.scholar_indx));
                }

                // 2. Name Search (Uses index for potential speedup, but needs filtering after)
                if (lowerSearchTerm) {
                    // We can't easily combine index range search with other filters without complex logic.
                    // So, we filter *after* potentially getting results from other indexes or iterating.
                    filters.push(narrator => narrator.name_lower.includes(lowerSearchTerm));
                    // If ONLY search is active, we could potentially use the 'name_lower' index,
                    // but combining it reliably with pagination and other filters is tricky without full iteration.
                    // Let's stick to post-filtering for simplicity here.
                }

                // 3. Grade Filter (Uses index)
                if (currentFilters.grade) {
                    index = store.index('grade');
                    range = IDBKeyRange.only(currentFilters.grade);
                    filters.push(narrator => narrator.grade === currentFilters.grade); // Still need this for multi-filter logic
                }

                // 4. Tag Filter (Uses index)
                if (currentFilters.tag) {
                    // If grade filter is also active, we can't use two indexes simultaneously.
                    // Prioritize grade index if present, otherwise use tag index.
                    if (!index) {
                        index = store.index('tags');
                        range = IDBKeyRange.only(currentFilters.tag);
                    }
                    filters.push(narrator => narrator.tags && narrator.tags.includes(currentFilters.tag));
                }

                 // 5. Category Filter (Uses index)
                if (currentFilters.category) {
                     if (!index) { // Only use index if no other index is already selected
                        index = store.index('categories');
                        range = IDBKeyRange.only(currentFilters.category);
                    }
                    filters.push(narrator => narrator.categories && narrator.categories.includes(currentFilters.category));
                }


                // --- Data Fetching and Pagination ---
                const allMatchingIds = [];
                let totalMatchingCount = 0;
                const source = index ? index.openCursor(range, direction) : store.openCursor(null, direction);
                const cursorReq = source;

                await new Promise((resolve, reject) => {
                    cursorReq.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const narrator = cursor.value;
                            // Apply all filters
                            let match = true;
                            for (const filterFn of filters) {
                                if (!filterFn(narrator)) {
                                    match = false;
                                    break;
                                }
                            }

                            if (match) {
                                totalMatchingCount++;
                                // Check if item falls within the current page range
                                const itemIndex = totalMatchingCount - 1; // 0-based index
                                if (itemIndex >= (currentPage - 1) * ITEMS_PER_PAGE && itemIndex < currentPage * ITEMS_PER_PAGE) {
                                    allMatchingIds.push(cursor.primaryKey); // Store ID
                                }
                            }
                            cursor.continue();
                        } else {
                            resolve(); // End of cursor
                        }
                    };
                    cursorReq.onerror = (event) => {
                        console.error("Cursor error:", event.target.error);
                        reject(event.target.error);
                    };
                });

                currentNarratorList = allMatchingIds;
                updatePaginationControls(totalMatchingCount);
                renderNarratorList(currentNarratorList);

            } catch (error) {
                console.error("Error loading narrators:", error);
                showStatusMessage(translate("Error loading narrator list:") + ` ${error.message}`, 'error');
                narratorListEl.innerHTML = `<li>${translate("Error loading narrator list:")} ${error.message}</li>`;
                updatePaginationControls(0); // Reset pagination on error
            } finally {
                hideLoading();
            }
        }

        function clearDetailsPanel() {
            detailsContentEl.innerHTML = `<p>${translate("Select a narrator from the list.")}</p>`;
            actionsSection.classList.add('hidden');
            notesTextarea.value = ''; // Clear notes textarea
        }

        function clearGraph() {
             graphSvg.innerHTML = ''; // Clear previous graph
             graphData = { nodes: [], links: [] }; // Reset graph data
        }

        function handleNarratorClick(id) {
            if (selectedNarratorId === id) return; // Already selected

            selectedNarratorId = id;

            // Highlight in list
            document.querySelectorAll('.narrator-item.selected').forEach(el => el.classList.remove('selected'));
            const listItem = narratorListEl.querySelector(`.narrator-item[data-id="${id}"]`);
            if (listItem) {
                listItem.classList.add('selected');
                // Scroll into view if needed
                listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Display details and update graph
            displayNarratorDetails(id);
            updateGraphVisualization(id);
            loadAndDisplayNote(id); // Load note for selected narrator
            updateBookmarkStatus(id); // Update bookmark button status
            actionsSection.classList.remove('hidden'); // Show actions section
        }

        function createDetailItem(labelKey, value, isHtml = false, valueClass = '') {
            if (value === null || value === undefined || value === '' || (Array.isArray(value) && value.length === 0)) {
                // Optionally hide N/A fields or display them consistently
                 // return ''; // Hide if empty
                 value = translate('N/A'); // Show N/A if empty
            }

            const label = translate(labelKey);
            const item = document.createElement('div');
            item.className = 'detail-item';

            const labelSpan = document.createElement('span');
            labelSpan.className = 'detail-label';
            labelSpan.textContent = `${label}:`;
            item.appendChild(labelSpan);

            const valueSpan = document.createElement('span');
            valueSpan.className = `detail-value ${valueClass}`;
            if (isHtml) {
                valueSpan.innerHTML = value;
            } else {
                valueSpan.textContent = value;
            }
            item.appendChild(valueSpan);

            return item;
        }

        // Helper to parse and link IDs in text fields
        function linkIdsInText(text, fieldName) {
            if (!text || typeof text !== 'string') return translate('N/A');

            // Match patterns like "Name [ID]" or just IDs if no name provided
            const regex = /\[(\d+)\]/g;
            let lastIndex = 0;
            const parts = [];

            let match;
            while ((match = regex.exec(text)) !== null) {
                const id = parseInt(match[1], 10);
                // Add text before the match
                if (match.index > lastIndex) {
                    parts.push(document.createTextNode(text.substring(lastIndex, match.index)));
                }
                // Add the link
                const link = document.createElement('a');
                link.href = '#'; // Prevent page jump
                link.dataset.id = id;
                link.textContent = `[${id}]`; // Display the ID in the link
                link.title = translate("Click to view") + ` ID ${id}`;
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    handleNarratorClick(id);
                });
                 // Try to find the name associated with this ID just before the brackets
                 let namePart = text.substring(lastIndex, match.index).trim();
                 // Remove trailing comma or other separators if present
                 namePart = namePart.replace(/[,;/]$/, '').trim();
                 // If a reasonable name part exists, use it as link text instead of just ID
                 if (namePart && namePart.length > 2 && !namePart.includes(',')) { // Basic check for a name
                     link.textContent = namePart + ` [${id}]`;
                 }

                parts.push(link);
                lastIndex = regex.lastIndex;
            }

            // Add any remaining text after the last match
            if (lastIndex < text.length) {
                parts.push(document.createTextNode(text.substring(lastIndex)));
            }

            if (parts.length === 0) {
                 return document.createTextNode(text); // No IDs found, return original text
            }

            const container = document.createDocumentFragment();
            parts.forEach(part => container.appendChild(part));
            return container;
        }

        // Helper to format list of IDs as clickable links
        function formatIdList(ids, labelKey) {
             if (!ids || !Array.isArray(ids) || ids.length === 0) {
                 return translate('N/A');
             }
             const fragment = document.createDocumentFragment();
             ids.forEach((id, index) => {
                 const link = document.createElement('a');
                 link.href = '#';
                 link.dataset.id = id;
                 link.textContent = id;
                 link.title = translate("Click to view") + ` ID ${id}`;
                 link.addEventListener('click', (e) => {
                     e.preventDefault();
                     handleNarratorClick(id);
                 });
                 fragment.appendChild(link);
                 if (index < ids.length - 1) {
                     fragment.appendChild(document.createTextNode(', '));
                 }
             });
             return fragment;
        }

        // Helper to format tags
        function formatTags(tags) {
            if (!tags || !Array.isArray(tags) || tags.length === 0) {
                return translate('N/A');
            }
            return tags.map(tag => `<span class="tag">${tag}</span>`).join(' ');
        }

        async function displayNarratorDetails(id) {
            showLoading("Loading narrator details...");
            try {
                const narrator = await getNarratorById(id);
                if (!narrator) {
                    detailsContentEl.innerHTML = `<p>${translate("Narrator not found:")} ${id}</p>`;
                    actionsSection.classList.add('hidden');
                    hideLoading();
                    return;
                }

                detailsContentEl.innerHTML = ''; // Clear previous details
                const fragment = document.createDocumentFragment();

                // Basic Info
                fragment.appendChild(createDetailItem('ID', narrator.scholar_indx));
                fragment.appendChild(createDetailItem('Name', narrator.name));
                fragment.appendChild(createDetailItem('Grade', narrator.grade));

                // Family
                fragment.appendChild(createDetailItem('Parents', linkIdsInText(narrator.parents, 'parents'), true));
                fragment.appendChild(createDetailItem('Spouse', linkIdsInText(narrator.spouse, 'spouse'), true));
                fragment.appendChild(createDetailItem('Siblings', linkIdsInText(narrator.siblings, 'siblings'), true));
                fragment.appendChild(createDetailItem('Children', linkIdsInText(narrator.children, 'children'), true));

                // Dates and Places
                fragment.appendChild(createDetailItem('Birth Date/Place', narrator.birth_date_place));
                fragment.appendChild(createDetailItem('Birth Place', narrator.birth_place));
                fragment.appendChild(createDetailItem('Birth Date', narrator.birth_date));
                fragment.appendChild(createDetailItem('Birth Date Hijri', narrator.birth_date_hijri));
                fragment.appendChild(createDetailItem('Birth Date Gregorian', narrator.birth_date_gregorian));
                fragment.appendChild(createDetailItem('Places of Stay', narrator.places_of_stay));
                fragment.appendChild(createDetailItem('Death Date/Place', narrator.death_date_place));
                fragment.appendChild(createDetailItem('Death Place', narrator.death_place));
                fragment.appendChild(createDetailItem('Death Date Hijri', narrator.death_date_hijri));
                fragment.appendChild(createDetailItem('Death Date Gregorian', narrator.death_date_gregorian));
                fragment.appendChild(createDetailItem('Death Reason', narrator.death_reason));


                // Relationships (using dedicated ID lists)
                fragment.appendChild(createDetailItem('Teachers', formatIdList(narrator.teachers_inds, 'Teachers'), true));
                fragment.appendChild(createDetailItem('Students', formatIdList(narrator.students_inds, 'Students'), true));

                // Other Info
                fragment.appendChild(createDetailItem('Area of Interest', (narrator.categories || []).join(', '))); // Use parsed categories
                fragment.appendChild(createDetailItem('Tags', formatTags(narrator.tags), true));
                fragment.appendChild(createDetailItem('Books', narrator.books || translate('N/A')));

                detailsContentEl.appendChild(fragment);
                actionsSection.classList.remove('hidden'); // Show actions now that details are loaded

            } catch (error) {
                console.error("Error displaying narrator details:", error);
                detailsContentEl.innerHTML = `<p>${translate("Error loading narrator details:")} ${error.message}</p>`;
                actionsSection.classList.add('hidden');
            } finally {
                hideLoading();
            }
        }

        // --- Bookmarks and Notes ---
        async function updateBookmarkStatus(scholar_indx) {
             if (!scholar_indx) {
                 bookmarkButton.textContent = translate("Bookmark");
                 bookmarkButton.disabled = true;
                 return;
             }
             bookmarkButton.disabled = false; // Enable button
             try {
                 const bookmarked = await isBookmarked(scholar_indx);
                 updateBookmarkButtonText(scholar_indx, bookmarked);
             } catch (error) {
                 console.error("Error checking bookmark status:", error);
                 bookmarkButton.textContent = translate("Error");
                 bookmarkButton.disabled = true;
             }
        }

         function updateBookmarkButtonText(scholar_indx, isBookmarkedState = null) {
             // This function only updates the text based on a known state or the current selected ID
             // It doesn't fetch the state itself unless needed.
             if (!scholar_indx) {
                 bookmarkButton.textContent = translate("Bookmark");
                 return;
             }

             if (isBookmarkedState !== null) {
                 bookmarkButton.textContent = isBookmarkedState ? translate("Remove Bookmark") : translate("Bookmark");
             } else {
                 // If state not provided, assume we need to update based on current selection (might re-fetch)
                 isBookmarked(scholar_indx).then(bookmarked => {
                     bookmarkButton.textContent = bookmarked ? translate("Remove Bookmark") : translate("Bookmark");
                 }).catch(() => {
                     bookmarkButton.textContent = translate("Error"); // Handle potential error during async check
                 });
             }
         }

        async function handleBookmarkClick() {
            if (!selectedNarratorId) return;
            showLoading("Updating bookmark...");
            try {
                const newState = await toggleBookmark(selectedNarratorId);
                updateBookmarkButtonText(selectedNarratorId, newState);
                showStatusMessage("Bookmark status updated.", 'success');
                // If bookmark filter is active, refresh the list
                if (currentFilters.bookmarkedOnly) {
                    await loadAndDisplayNarrators(currentPage);
                }
            } catch (error) {
                console.error("Error toggling bookmark:", error);
                showStatusMessage(translate("Error updating bookmark:") + ` ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function loadAndDisplayNote(scholar_indx) {
             if (!scholar_indx) {
                 notesTextarea.value = '';
                 notesTextarea.disabled = true;
                 saveNoteButton.disabled = true;
                 return;
             }
             notesTextarea.disabled = false;
             saveNoteButton.disabled = false;
             showLoading("Loading note...");
             try {
                 const noteText = await getNote(scholar_indx);
                 notesTextarea.value = noteText || '';
             } catch (error) {
                 console.error("Error loading note:", error);
                 notesTextarea.value = translate("Error loading note:") + ` ${error.message}`;
                 notesTextarea.disabled = true;
                 saveNoteButton.disabled = true;
                 showStatusMessage(translate("Error loading note:") + ` ${error.message}`, 'error');
             } finally {
                 hideLoading();
             }
        }

        async function handleSaveNoteClick() {
            if (!selectedNarratorId) return;
            const noteText = notesTextarea.value.trim();
            showLoading("Saving note...");
            try {
                await saveNote(selectedNarratorId, noteText);
                showStatusMessage("Note saved.", 'success');
            } catch (error) {
                console.error("Error saving note:", error);
                showStatusMessage(translate("Error saving note:") + ` ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // --- Visualization (SVG Graph) ---

        function initGraphZoomPan() {
            const svg = graphSvg;
            const container = graphContainer;
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            let endPoint = { x: 0, y: 0 };
            let scale = 1;
            let viewBox = { x: 0, y: 0, width: svg.clientWidth || 600, height: svg.clientHeight || 400 }; // Initial guess

            // Ensure initial viewBox is set based on SVG size
             function setInitialViewBox() {
                 const bounds = svg.getBoundingClientRect();
                 if (bounds.width > 0 && bounds.height > 0) {
                     viewBox.width = bounds.width;
                     viewBox.height = bounds.height;
                     svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
                     console.log("Initial viewBox set:", viewBox);
                 } else {
                     // Fallback if SVG size not yet determined
                     setTimeout(setInitialViewBox, 100);
                 }
             }
             setInitialViewBox();


            function getPoint(event) {
                let point = svg.createSVGPoint();
                if (event.touches) {
                    point.x = event.touches[0].clientX;
                    point.y = event.touches[0].clientY;
                } else {
                    point.x = event.clientX;
                    point.y = event.clientY;
                }
                 // Transform client coords to SVG coords
                 try {
                    const ctm = svg.getScreenCTM().inverse();
                    point = point.matrixTransform(ctm);
                 } catch(e) {
                     console.warn("Could not get screen CTM inverse:", e);
                     // Use simpler offset if CTM fails (less accurate with transforms)
                     const rect = svg.getBoundingClientRect();
                     point.x = (event.clientX - rect.left) / scale;
                     point.y = (event.clientY - rect.top) / scale;
                 }

                return point;
            }

            function onPointerDown(event) {
                if (event.button !== 0 && event.type !== 'touchstart') return; // Only left click or touch
                isPanning = true;
                startPoint = getPoint(event);
                container.style.cursor = 'grabbing';
                // Prevent text selection during drag
                event.preventDefault();
            }

            function onPointerMove(event) {
                if (!isPanning) return;
                endPoint = getPoint(event);
                let dx = (startPoint.x - endPoint.x);
                let dy = (startPoint.y - endPoint.y);
                viewBox.x += dx;
                viewBox.y += dy;
                svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
                 // No need to update startPoint here, the delta is relative to the original start
            }

            function onPointerUp(event) {
                if (!isPanning) return;
                isPanning = false;
                container.style.cursor = 'grab';
            }

             function onWheel(event) {
                event.preventDefault();
                const zoomIntensity = 0.1;
                const delta = event.deltaY > 0 ? (1 + zoomIntensity) : (1 - zoomIntensity); // Zoom factor
                const mousePoint = getPoint(event);

                // Calculate new viewBox dimensions
                const newWidth = viewBox.width * delta;
                const newHeight = viewBox.height * delta;

                 // Calculate new viewBox origin to keep mouse point stationary
                 viewBox.x = mousePoint.x - (mousePoint.x - viewBox.x) * delta;
                 viewBox.y = mousePoint.y - (mousePoint.y - viewBox.y) * delta;
                 viewBox.width = newWidth;
                 viewBox.height = newHeight;


                svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
                scale = (svg.clientWidth || viewBox.width) / viewBox.width; // Update scale approx
            }

            // Attach Listeners
            container.addEventListener('mousedown', onPointerDown);
            container.addEventListener('mousemove', onPointerMove);
            container.addEventListener('mouseup', onPointerUp);
            container.addEventListener('mouseleave', onPointerUp); // Stop panning if mouse leaves container
            container.addEventListener('wheel', onWheel, { passive: false });

            // Touch events (basic mapping)
            container.addEventListener('touchstart', onPointerDown, { passive: false });
            container.addEventListener('touchmove', onPointerMove, { passive: false });
            container.addEventListener('touchend', onPointerUp);
            container.addEventListener('touchcancel', onPointerUp);

             // Store current state for potential reset or external use
             currentViewBox = viewBox;
             currentScale = scale;
        }

        // Simple layout function (radial or layered)
        function simpleLayout(centerNode, teachers, students) {
            const nodes = [];
            const links = [];
            const nodeMap = new Map(); // Track node positions

            const radius = 150; // Distance for related nodes
            const angleStepTeacher = teachers.length > 0 ? (Math.PI * 1.5) / (teachers.length + 1) : 0; // Spread teachers over ~270 deg top/left
            const angleStepStudent = students.length > 0 ? (Math.PI * 1.5) / (students.length + 1) : 0; // Spread students over ~270 deg bottom/right

            // Center Node
            const centerX = (graphSvg.clientWidth || 600) / 2;
            const centerY = (graphSvg.clientHeight || 400) / 2;
            nodes.push({ id: centerNode.scholar_indx, name: centerNode.name, x: centerX, y: centerY, isCenter: true });
            nodeMap.set(centerNode.scholar_indx, { x: centerX, y: centerY });

            // Teacher Nodes (position above/left)
            teachers.forEach((teacher, i) => {
                const angle = (Math.PI * 1.25) - (angleStepTeacher * (i + 1)); // Start from top-left-ish
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                if (!nodeMap.has(teacher.scholar_indx)) {
                    nodes.push({ id: teacher.scholar_indx, name: teacher.name, x: x, y: y });
                    nodeMap.set(teacher.scholar_indx, { x: x, y: y });
                }
                links.push({ source: teacher.scholar_indx, target: centerNode.scholar_indx, type: 'teacher' });
            });

            // Student Nodes (position below/right)
            students.forEach((student, i) => {
                const angle = (Math.PI * 0.25) + (angleStepStudent * (i + 1)); // Start from bottom-right-ish
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                 if (!nodeMap.has(student.scholar_indx)) {
                    nodes.push({ id: student.scholar_indx, name: student.name, x: x, y: y });
                    nodeMap.set(student.scholar_indx, { x: x, y: y });
                }
                links.push({ source: centerNode.scholar_indx, target: student.scholar_indx, type: 'student' });
            });

            return { nodes, links };
        }


        async function updateGraphVisualization(centerNarratorId) {
            showLoading("Loading graph...");
            graphSvg.innerHTML = ''; // Clear previous graph

            try {
                const centerNarrator = await getNarratorById(centerNarratorId);
                if (!centerNarrator) throw new Error("Center narrator not found.");

                const teacherIds = centerNarrator.teachers_inds || [];
                const studentIds = centerNarrator.students_inds || [];

                const teacherPromises = teacherIds.map(id => getNarratorById(id));
                const studentPromises = studentIds.map(id => getNarratorById(id));

                const teachers = (await Promise.all(teacherPromises)).filter(n => n); // Filter out nulls if any ID not found
                const students = (await Promise.all(studentPromises)).filter(n => n);

                // --- Layout ---
                // Use a simple layout for now
                const layout = simpleLayout(centerNarrator, teachers, students);
                graphData = layout; // Store the calculated layout

                // --- Rendering (using SVG) ---
                const svgNS = "http://www.w3.org/2000/svg";
                const group = document.createElementNS(svgNS, 'g'); // Group for zoom/pan
                graphSvg.appendChild(group);

                // Render Links (Edges) first so nodes are on top
                layout.links.forEach(link => {
                    const sourceNode = layout.nodes.find(n => n.id === link.source);
                    const targetNode = layout.nodes.find(n => n.id === link.target);
                    if (!sourceNode || !targetNode) return; // Skip if node data missing

                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', sourceNode.x);
                    line.setAttribute('y1', sourceNode.y);
                    line.setAttribute('x2', targetNode.x);
                    line.setAttribute('y2', targetNode.y);
                    line.classList.add('link');
                    if (link.type === 'teacher') line.classList.add('teacher-link');
                    if (link.type === 'student') line.classList.add('student-link');
                    group.appendChild(line);
                });

                // Render Nodes
                layout.nodes.forEach(node => {
                    const nodeGroup = document.createElementNS(svgNS, 'g');
                    nodeGroup.classList.add('node');
                    nodeGroup.setAttribute('transform', `translate(${node.x},${node.y})`);
                    nodeGroup.dataset.id = node.id;
                    if (node.id === centerNarratorId) {
                        nodeGroup.classList.add('selected'); // Highlight center node
                    }

                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('r', node.isCenter ? 8 : 5); // Make center node slightly larger
                    nodeGroup.appendChild(circle);

                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('dy', node.isCenter ? '-1.2em' : '-0.8em'); // Position text above node
                    // Truncate long names for display
                    const displayName = (node.name || 'Unknown').length > 20 ? node.name.substring(0, 18) + '...' : node.name;
                    text.textContent = displayName;
                    nodeGroup.appendChild(text);

                    // Add click listener to nodes
                    nodeGroup.addEventListener('click', () => handleNarratorClick(node.id));

                    group.appendChild(nodeGroup);
                });

                 // Initialize or re-apply zoom/pan AFTER content is added
                 // If first time, init. If already initialized, maybe reset view?
                 // For simplicity, let's assume initGraphZoomPan handles attaching listeners once.
                 // We might need to reset the viewbox if the layout changes significantly.
                 // Let's reset the view to fit the new content (simple approach)
                 const bounds = group.getBBox();
                 const padding = 50; // Add some padding around the content
                 if (bounds.width > 0 && bounds.height > 0) {
                     currentViewBox.x = bounds.x - padding;
                     currentViewBox.y = bounds.y - padding;
                     currentViewBox.width = bounds.width + 2 * padding;
                     currentViewBox.height = bounds.height + 2 * padding;
                     graphSvg.setAttribute('viewBox', `${currentViewBox.x} ${currentViewBox.y} ${currentViewBox.width} ${currentViewBox.height}`);
                     currentScale = (graphSvg.clientWidth || currentViewBox.width) / currentViewBox.width;
                 }


                console.log("Graph loaded.");
                showStatusMessage("Graph loaded.", 'info');

            } catch (error) {
                console.error("Error updating graph:", error);
                graphSvg.innerHTML = `<text x="10" y="20" fill="var(--error-color)">${translate("Error loading graph:")} ${error.message}</text>`;
                showStatusMessage(translate("Error loading graph:") + ` ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        function handlePrintViz() {
            try {
                // Optionally adjust SVG styles for printing if CSS @media print isn't sufficient
                // e.g., ensure strokes/fills are dark enough
                window.print();
            } catch (error) {
                 console.error("Error initiating print:", error);
                 showStatusMessage(translate("Error initiating print:") + ` ${error.message}`, 'error');
            }
        }

        // --- Relationship Path Tracing ---

        async function findNarratorForPath(searchTerm) {
             const term = searchTerm.trim();
             if (!term) return null;

             // Check cache first
             if (pathSearchCache[term]) return pathSearchCache[term];

             let narrator = null;
             // Try searching by ID first
             if (/^\d+$/.test(term)) {
                 const id = parseInt(term, 10);
                 narrator = await getNarratorById(id);
             }

             // If not found by ID or term wasn't an ID, search by name (case-insensitive)
             if (!narrator) {
                 const lowerTerm = term.toLowerCase();
                 const transaction = db.transaction(NARRATORS_STORE, 'readonly');
                 const store = transaction.objectStore(NARRATORS_STORE);
                 const index = store.index('name_lower'); // Use the name index
                 const request = index.openCursor(); // Iterate through names

                 narrator = await new Promise((resolve, reject) => {
                     request.onsuccess = (event) => {
                         const cursor = event.target.result;
                         if (cursor) {
                             // Check for exact match or partial match (more flexible)
                             if (cursor.value.name_lower.includes(lowerTerm)) {
                                 resolve(cursor.value); // Found a match
                                 return;
                             }
                             cursor.continue();
                         } else {
                             resolve(null); // No match found
                         }
                     };
                     request.onerror = (event) => reject(event.target.error);
                 });
             }

             // Cache the result (even if null)
             pathSearchCache[term] = narrator;
             return narrator;
        }

        async function handlePathSearchInput(inputId, displayId) {
             const inputEl = document.getElementById(inputId);
             const displayEl = document.getElementById(displayId);
             const hiddenInputEl = document.getElementById(inputId.replace('-search', ''));

             const searchTerm = inputEl.value;
             displayEl.textContent = translate("Searching...");
             hiddenInputEl.value = '';

             try {
                 const narrator = await findNarratorForPath(searchTerm);
                 if (narrator) {
                     displayEl.textContent = `${narrator.name} [${narrator.scholar_indx}]`;
                     hiddenInputEl.value = narrator.scholar_indx;
                 } else {
                     displayEl.textContent = translate("Narrator not found:");
                 }
             } catch (error) {
                 console.error("Path search error:", error);
                 displayEl.textContent = translate("Error searching narrator for path:");
             }
        }

        // Debounced search handlers
        const debouncedPathStartSearch = debounce(() => handlePathSearchInput('path-start-node-search', 'path-start-node-display'), 500);
        const debouncedPathEndSearch = debounce(() => handlePathSearchInput('path-end-node-search', 'path-end-node-display'), 500);


        async function tracePath() {
            const startId = parseInt(pathStartNodeInput.value, 10);
            const endId = parseInt(pathEndNodeInput.value, 10);
            pathResultEl.innerHTML = ''; // Clear previous results

            if (isNaN(startId) || isNaN(endId)) {
                showStatusMessage("Please select both start and end narrators.", 'warning');
                return;
            }

            if (startId === endId) {
                 pathResultEl.innerHTML = `<p>${translate("Start and end narrators are the same.")}</p>`;
                 return;
            }


            showLoading("Finding path...");

            try {
                // Breadth-First Search (BFS) to find the shortest path
                const queue = [[startId]]; // Queue stores paths (arrays of IDs)
                const visited = new Set([startId]); // Keep track of visited nodes to avoid cycles

                while (queue.length > 0) {
                    const currentPath = queue.shift();
                    const lastNodeId = currentPath[currentPath.length - 1];

                    // Get neighbors (teachers and students) of the last node
                    const lastNode = await getNarratorById(lastNodeId);
                    if (!lastNode) continue; // Skip if narrator data not found

                    const neighbors = [
                        ...(lastNode.teachers_inds || []),
                        ...(lastNode.students_inds || [])
                    ];

                    for (const neighborId of neighbors) {
                        if (neighborId === endId) {
                            // Path found!
                            const fullPath = [...currentPath, neighborId];
                            await displayPathResult(fullPath);
                            hideLoading();
                            return; // Found the shortest path
                        }

                        if (!visited.has(neighborId)) {
                            visited.add(neighborId);
                            const newPath = [...currentPath, neighborId];
                            queue.push(newPath);
                        }
                    }
                     // Optimization: Limit search depth or queue size if performance becomes an issue
                     if (queue.length > 5000 || currentPath.length > 15) { // Example limits
                         throw new Error("Search depth or breadth limit reached. Path might be too long or complex.");
                     }
                }

                // If queue empties and endId not found
                pathResultEl.innerHTML = `<p>${translate("No path found between the selected narrators.")}</p>`;

            } catch (error) {
                console.error("Error finding path:", error);
                pathResultEl.innerHTML = `<p>${translate("Error finding path:")} ${error.message}</p>`;
                showStatusMessage(translate("Error finding path:") + ` ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function displayPathResult(pathIds) {
             pathResultEl.innerHTML = `<strong>${translate("Path found:")}</strong>`;
             const list = document.createElement('ol');
             const narratorPromises = pathIds.map(id => getNarratorById(id));
             const narrators = await Promise.all(narratorPromises);

             narrators.forEach((narrator, index) => {
                 const li = document.createElement('li');
                 if (narrator) {
                     const link = document.createElement('a');
                     link.href = '#';
                     link.dataset.id = narrator.scholar_indx;
                     link.textContent = `${narrator.name} [${narrator.scholar_indx}]`;
                     link.addEventListener('click', (e) => {
                         e.preventDefault();
                         handleNarratorClick(narrator.scholar_indx);
                     });
                     li.appendChild(link);
                 } else {
                     li.textContent = `${translate("Unknown Narrator")} [${pathIds[index]}]`;
                 }
                 list.appendChild(li);
             });
             pathResultEl.appendChild(list);
        }


        // --- Export / Import ---

        async function exportData() {
            showLoading("Exporting data...");
            try {
                const narrators = await getAllRecords(NARRATORS_STORE);
                const bookmarks = await getAllRecords(BOOKMARKS_STORE);
                const notes = await getAllRecords(NOTES_STORE);
                const metadata = await getAllRecords(METADATA_STORE);

                const exportObj = {
                    version: 1, // Add a version number for future compatibility
                    exportDate: new Date().toISOString(),
                    data: {
                        [NARRATORS_STORE]: narrators,
                        [BOOKMARKS_STORE]: bookmarks,
                        [NOTES_STORE]: notes,
                        [METADATA_STORE]: metadata
                    }
                };

                const jsonString = JSON.stringify(exportObj, null, 2); // Pretty print JSON
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `isnad_export_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatusMessage("Data exported successfully as '{filename}'.", 'success', {filename: a.download});
                console.log("Export complete.");
            } catch (error) {
                console.error("Export failed:", error);
                showStatusMessage(translate("Error exporting data:") + ` ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        function handleImportClick() {
            // Trigger the hidden file input
            importFileEl.click();
        }

        async function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                showStatusMessage("Please select a JSON file.", 'warning');
                return;
            }

            // Confirmation
            if (!confirm(translate("Are you sure you want to import data? This will overwrite all existing narrators, bookmarks, and notes."))) {
                 showStatusMessage("Import Cancelled.", 'info');
                 event.target.value = null; // Reset file input
                 return;
            }


            showLoading("Importing data... This will replace existing data.");
            const reader = new FileReader();

            reader.onload = async (e) => {
                try {
                    const jsonString = e.target.result;
                    const importObj = JSON.parse(jsonString);

                    // Basic validation
                    if (!importObj || typeof importObj !== 'object' || !importObj.data || !importObj.version) {
                        throw new Error(translate("Invalid file format or corrupted data."));
                    }
                    if (importObj.version !== 1) {
                         console.warn(`Importing data from version ${importObj.version}. Current version is 1. Compatibility issues may arise.`);
                         // Add migration logic here if needed in the future
                    }

                    const dataToImport = importObj.data;

                    // Clear existing data
                    showLoading("Clearing existing data...");
                    await clearStore(NARRATORS_STORE);
                    await clearStore(BOOKMARKS_STORE);
                    await clearStore(NOTES_STORE);
                    await clearStore(METADATA_STORE);

                    // Import new data
                    if (dataToImport[NARRATORS_STORE]) {
                        showLoading(translate("Importing narrators ({count})...", currentLanguage, {count: dataToImport[NARRATORS_STORE].length}));
                        await bulkAdd(NARRATORS_STORE, dataToImport[NARRATORS_STORE]);
                    }
                    if (dataToImport[BOOKMARKS_STORE]) {
                         showLoading(translate("Importing bookmarks ({count})...", currentLanguage, {count: dataToImport[BOOKMARKS_STORE].length}));
                        await bulkAdd(BOOKMARKS_STORE, dataToImport[BOOKMARKS_STORE]);
                    }
                    if (dataToImport[NOTES_STORE]) {
                         showLoading(translate("Importing notes ({count})...", currentLanguage, {count: dataToImport[NOTES_STORE].length}));
                        await bulkAdd(NOTES_STORE, dataToImport[NOTES_STORE]);
                    }
                     if (dataToImport[METADATA_STORE]) {
                         showLoading("Importing metadata...");
                        await bulkAdd(METADATA_STORE, dataToImport[METADATA_STORE]);
                    }

                    console.log("Data import complete.");
                    showLoading("Import successful! Reloading data...");
                    showStatusMessage("Import successful! Reloading data...", 'success');

                    // Reload the application state from the newly imported data
                    await initializeApp(); // Re-initialize to load filters and display data

                } catch (error) {
                    console.error("Import failed:", error);
                    showStatusMessage(translate("Error importing data:") + ` ${error.message}`, 'error', {}, 0); // Keep error visible
                    hideLoading();
                } finally {
                    event.target.value = null; // Reset file input
                }
            };

            reader.onerror = (e) => {
                console.error("File reading error:", e);
                showStatusMessage(translate("File error:") + ` ${reader.error}`, 'error');
                hideLoading();
                event.target.value = null; // Reset file input
            };

            reader.readAsText(file);
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            // Search and Filters
            searchInput.addEventListener('input', debounce(() => {
                currentFilters.search = searchInput.value;
                loadAndDisplayNarrators(1); // Go to page 1 on new search
            }, 300)); // Debounce search input

            gradeFilter.addEventListener('change', () => {
                currentFilters.grade = gradeFilter.value;
                loadAndDisplayNarrators(1);
            });

            tagFilter.addEventListener('change', () => {
                currentFilters.tag = tagFilter.value;
                loadAndDisplayNarrators(1);
            });

             categoryFilter.addEventListener('change', () => {
                currentFilters.category = categoryFilter.value;
                loadAndDisplayNarrators(1);
            });

            bookmarksFilterBtn.addEventListener('click', () => {
                currentFilters.bookmarkedOnly = !currentFilters.bookmarkedOnly;
                updateBookmarksFilterButtonText();
                loadAndDisplayNarrators(1);
            });

            resetFiltersBtn.addEventListener('click', () => {
                currentFilters = { search: '', grade: '', tag: '', category: '', bookmarkedOnly: false };
                searchInput.value = '';
                gradeFilter.value = '';
                tagFilter.value = '';
                categoryFilter.value = '';
                updateBookmarksFilterButtonText(); // Reset button text
                loadAndDisplayNarrators(1);
            });

            // Pagination
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    loadAndDisplayNarrators(currentPage - 1);
                }
            });

            nextPageBtn.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    loadAndDisplayNarrators(currentPage + 1);
                }
            });

            // Header Controls
            langToggleBtn.addEventListener('click', () => {
                setLanguage(currentLanguage === 'en' ? 'ur' : 'en');
            });

            themeToggleBtn.addEventListener('click', () => {
                setTheme(currentTheme === 'light' ? 'dark' : 'light');
            });

            exportBtn.addEventListener('click', exportData);
            importBtn.addEventListener('click', handleImportClick);
            importFileEl.addEventListener('change', importData);

            // Details Actions
            bookmarkButton.addEventListener('click', handleBookmarkClick);
            saveNoteButton.addEventListener('click', handleSaveNoteClick);

            // Visualization
            printVizBtn.addEventListener('click', handlePrintViz);
            initGraphZoomPan(); // Initialize zoom/pan listeners for the graph container

             // Path Tracing
             pathStartSearch.addEventListener('input', debouncedPathStartSearch);
             pathEndSearch.addEventListener('input', debouncedPathEndSearch);
             tracePathButton.addEventListener('click', tracePath);

             // Window resize listener for graph responsiveness (optional but good)
             window.addEventListener('resize', debounce(() => {
                 if (selectedNarratorId) {
                     // Re-calculate layout or just reset viewbox on resize
                     // Simple approach: reset viewbox based on current SVG size
                     const svg = graphSvg;
                     const bounds = svg.getBoundingClientRect();
                     if (bounds.width > 0 && bounds.height > 0) {
                         // Try to maintain current center and scale if possible, or just reset
                         // Resetting is easier:
                         updateGraphVisualization(selectedNarratorId); // This recalculates layout and resets view
                     }
                 }
             }, 250));
        }

         function updateBookmarksFilterButtonText() {
             if (currentFilters.bookmarkedOnly) {
                 bookmarksFilterBtn.textContent = translate("Show All");
                 bookmarksFilterBtn.classList.add('active'); // Optional: style active state
             } else {
                 bookmarksFilterBtn.textContent = translate("Show Bookmarks");
                 bookmarksFilterBtn.classList.remove('active');
             }
         }


        // --- App Entry Point ---
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            initializeApp();
        });

    </script>

</body>
</html>
